# -*- coding: utf-8 -*-
"""
RF Futures Bot â€” RF-LIVE ONLY (BingX - XAU/USDT)
â€¢ Council ULTIMATE with Smart Money Concepts & Advanced Indicators
â€¢ Golden Entry + Golden Reversal + Wick Exhaustion + Smart Exit
â€¢ Dynamic TP ladder + ATR-trailing + Volume Momentum + Liquidity Analysis
â€¢ Professional Logging & Dashboard + BingX Support
â€¢ ENHANCED: Smart Patience System + Intelligent Monitoring + Advanced Profit Management
"""

import os, time, math, random, signal, sys, traceback, logging, json
from logging.handlers import RotatingFileHandler
from datetime import datetime
import pandas as pd
import numpy as np
import ccxt
from flask import Flask, jsonify
from decimal import Decimal, ROUND_DOWN, InvalidOperation

try:
    from termcolor import colored
except Exception:
    def colored(t,*a,**k): return t

# =================== HELPER FUNCTIONS ===================
def last_val(x):
    """ÙŠØ±Ø¬Ø¹ Ø¢Ø®Ø± Ù‚ÙŠÙ…Ø© Ù…Ù† Series Ø£Ùˆ ndarray Ø£Ùˆ list Ø¨Ø£Ù…Ø§Ù† ÙƒÙ€ float."""
    try:
        if hasattr(x, "iloc"):   # pandas Series
            return float(x.iloc[-1])
        elif hasattr(x, "__len__") and len(x) > 0:
            return float(x[-1])
        return float(x)
    except Exception:
        return 0.0

def safe_iloc(series, index=-1):
    """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù‚ÙŠÙ…Ø© Ù…Ù† Series Ø£Ùˆ array Ø¨Ø£Ù…Ø§Ù†"""
    try:
        if hasattr(series, 'iloc'):
            return float(series.iloc[index])
        elif hasattr(series, '__getitem__'):
            return float(series[index])
        else:
            return float(series)
    except (IndexError, TypeError, ValueError):
        return 0.0

# =================== ENV / MODE ===================
# Exchange Selection - BingX Only
EXCHANGE_NAME = "bingx"

# API Keys - BingX
API_KEY = os.getenv("BINGX_API_KEY", "")
API_SECRET = os.getenv("BINGX_API_SECRET", "")

MODE_LIVE = bool(API_KEY and API_SECRET)

SELF_URL = os.getenv("SELF_URL", "") or os.getenv("RENDER_EXTERNAL_URL", "")
PORT = int(os.getenv("PORT", 5000))

# ==== Run mode / Logging toggles ====
LOG_LEGACY = False
LOG_ADDONS = True

# ==== Execution Switches ====
EXECUTE_ORDERS = True
SHADOW_MODE_DASHBOARD = False
DRY_RUN = False

# ==== Addon: Logging + Recovery Settings ====
BOT_VERSION = f"XAU Council PROFESSIONAL v8.0 â€” BINGX Gold Trading â€” ENHANCED MONITORING"
print("ğŸ” Booting:", BOT_VERSION, flush=True)

STATE_PATH = "./bot_state.json"
RESUME_ON_RESTART = True
RESUME_LOOKBACK_SECS = 60 * 60

# === Addons config ===
BOOKMAP_DEPTH = 50
BOOKMAP_TOPWALLS = 3
IMBALANCE_ALERT = 1.30

FLOW_WINDOW = 20
FLOW_SPIKE_Z = 1.60
CVD_SMOOTH = 8

# =================== SMART MONEY CONCEPTS SETTINGS ===================
FVG_THRESHOLD = 0.15  # Increased for Gold volatility
OB_STRENGTH_THRESHOLD = 0.15  # Increased for Gold
LIQUIDITY_ZONE_PROXIMITY = 0.015  # 1.5% proximity for Gold

# =================== FOOTPRINT ANALYSIS SETTINGS ===================
FOOTPRINT_PERIOD = 20
FOOTPRINT_VOLUME_THRESHOLD = 2.0
DELTA_THRESHOLD = 1.5
ABSORPTION_RATIO = 0.65
EFFICIENCY_THRESHOLD = 0.85

# =================== SETTINGS ===================
SYMBOL     = "XAU-USDT"  # Gold vs USDT - BingX correct format
INTERVAL   = os.getenv("INTERVAL", "15m")
LEVERAGE   = int(os.getenv("LEVERAGE", 10))
RISK_ALLOC = float(os.getenv("RISK_ALLOC", 0.30))  # 30% risk allocation
POSITION_MODE = "oneway"

# RF Settings - Optimized for XAU (Gold)
RF_SOURCE = "close"
RF_PERIOD = int(os.getenv("RF_PERIOD", 20))
RF_MULT   = float(os.getenv("RF_MULT", 3.5))
RF_LIVE_ONLY = True
RF_HYST_BPS  = 8.0

# Indicators
RSI_LEN = 14
ADX_LEN = 14
ATR_LEN = 14

ENTRY_RF_ONLY = False
MAX_SPREAD_BPS = float(os.getenv("MAX_SPREAD_BPS", 8.0))  # Increased for Gold

# Dynamic TP / trail - Optimized for XAU
TP1_PCT_BASE       = 0.60  # Increased for Gold volatility
TP1_CLOSE_FRAC     = 0.40
BREAKEVEN_AFTER    = 0.40
TRAIL_ACTIVATE_PCT = 1.50  # Increased for Gold trends
ATR_TRAIL_MULT     = 2.0

TREND_TPS       = [0.80, 1.50, 2.50]  # Increased for Gold
TREND_TP_FRACS  = [0.30, 0.30, 0.20]

# Dust guard - Adjusted for Gold (higher minimum)
FINAL_CHUNK_QTY = float(os.getenv("FINAL_CHUNK_QTY", 0.01))  # 0.01 XAU
RESIDUAL_MIN_QTY = float(os.getenv("RESIDUAL_MIN_QTY", 0.02))  # 0.02 XAU

# Strict close
CLOSE_RETRY_ATTEMPTS = 6
CLOSE_VERIFY_WAIT_S  = 2.0

# Pacing
BASE_SLEEP   = 5
NEAR_CLOSE_S = 1

# ==== Smart Exit Tuning ===
TP1_SCALP_PCT      = 0.50/100  # Increased for Gold
TP1_TREND_PCT      = 0.80/100
HARD_CLOSE_PNL_PCT = 1.50/100  # Increased for Gold
WICK_ATR_MULT      = 1.8
BM_WALL_PROX_BPS   = 8
TIME_IN_TRADE_MIN  = 10
TRAIL_TIGHT_MULT   = 1.30

# ==== Golden Entry Settings ====
GOLDEN_ENTRY_SCORE = 6.5  # Slightly higher for Gold
GOLDEN_ENTRY_ADX   = 22.0
GOLDEN_REVERSAL_SCORE = 7.0

# ==== Golden Zone Constants ====
FIB_LOW, FIB_HIGH = 0.618, 0.786
MIN_WICK_PCT = 0.40  # Increased for Gold
VOL_MA_LEN = 20
RSI_LEN_GZ, RSI_MA_LEN_GZ = 14, 9
MIN_DISP = 1.0  # Increased for Gold volatility

# ==== Execution & Strategy Thresholds ====
ADX_TREND_MIN = 22  # Increased for Gold
DI_SPREAD_TREND = 8
RSI_MA_LEN = 9
RSI_NEUTRAL_BAND = (40, 60)  # Wider for Gold
RSI_TREND_PERSIST = 3

GZ_MIN_SCORE = 6.5  # Increased for Gold
GZ_REQ_ADX = 22
GZ_REQ_VOL_MA = 20
ALLOW_GZ_ENTRY = True

SCALP_TP1 = 0.60
SCALP_BE_AFTER = 0.40
SCALP_ATR_MULT = 1.8
TREND_TP1 = 1.50
TREND_BE_AFTER = 1.00
TREND_ATR_MULT = 2.0

MAX_TRADES_PER_HOUR = 4  # Reduced for Gold
COOLDOWN_SECS_AFTER_CLOSE = 90
ADX_GATE = 18

# ==== ULTIMATE COUNCIL SETTINGS ====
ULTIMATE_MIN_CONFIDENCE = 7.5  # Increased for Gold
VOLUME_MOMENTUM_PERIOD = 20
STOCH_RSI_PERIOD = 14
DYNAMIC_PIVOT_PERIOD = 20
TREND_FAST_PERIOD = 10
TREND_SLOW_PERIOD = 20
TREND_SIGNAL_PERIOD = 9

# =================== ENHANCED SYSTEMS ===================
class SmartPatienceSystem:
    def __init__(self):
        self.entry_time = None
        self.minimum_hold_time = 120  # 2 Ø¯Ù‚Ø§Ø¦Ù‚ ÙƒØ­Ø¯ Ø£Ø¯Ù†Ù‰ Ù„Ù„ØµØ¨Ø±
        self.volatility_adjustment = 1.0
        
    def calculate_required_patience(self, df, atr, current_price):
        """Ø­Ø³Ø§Ø¨ ÙˆÙ‚Øª Ø§Ù„ØµØ¨Ø± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ‚Ù„Ø¨Ø§Øª ÙˆØ§Ù„Ø²Ø®Ù…"""
        if len(df) < 20:
            return self.minimum_hold_time
            
        # Ù‚ÙŠØ§Ø³ Ø§Ù„ØªÙ‚Ù„Ø¨Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
        recent_volatility = df['close'].pct_change().tail(20).std() * 100
        volatility_factor = max(0.5, min(2.0, recent_volatility / 0.5))
        
        # Ù‚ÙŠØ§Ø³ Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
        momentum = (current_price - df['close'].iloc[-5]) / df['close'].iloc[-5] * 100
        momentum_factor = 1.0 if abs(momentum) < 1.0 else 0.7
        
        required_time = self.minimum_hold_time * volatility_factor * momentum_factor
        return max(60, min(300, required_time))  # Ø¨ÙŠÙ† 1-5 Ø¯Ù‚Ø§Ø¦Ù‚

    def should_hold_position(self, entry_time, current_pnl, df, atr, current_price):
        """ØªØ­Ø¯ÙŠØ¯ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ¬Ø¨ Ø§Ù„Ø¥Ø¨Ù‚Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„ØµÙÙ‚Ø©"""
        if entry_time is None:
            return True
            
        hold_time = time.time() - entry_time
        required_time = self.calculate_required_patience(df, atr, current_price)
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙˆÙ‚Øª Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ÙˆØ§Ù„Ø±Ø¨Ø­ Ø¥ÙŠØ¬Ø§Ø¨ÙŠØŒ Ø§Ø³ØªÙ…Ø±
        if hold_time < required_time and current_pnl > -0.1:  # Ù„Ø§ Ù†Ø®Ø³Ø± Ø£ÙƒØ«Ø± Ù…Ù† 0.1%
            return True
            
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ø¨Ø­ Ø³Ù„Ø¨ÙŠ Ù„ÙƒÙ† Ø§Ù„ØªÙ‚Ù„Ø¨Ø§Øª Ø¹Ø§Ù„ÙŠØ©ØŒ Ø£Ø¹Ø· ÙØ±ØµØ© Ø£ÙƒØ«Ø±
        if current_pnl < 0 and hold_time < required_time * 1.5:
            recent_volatility = df['close'].pct_change().tail(10).std() * 100
            if recent_volatility > 0.8:  # ØªÙ‚Ù„Ø¨Ø§Øª Ø¹Ø§Ù„ÙŠØ©
                return True
                
        return False

class IntelligentPositionMonitor:
    def __init__(self):
        self.monitoring_active = False
        self.last_analysis_time = 0
        self.analysis_interval = 30  # Ø«Ø§Ù†ÙŠØ© Ø¨ÙŠÙ† ÙƒÙ„ ØªØ­Ù„ÙŠÙ„
        self.peak_profit = 0
        self.profit_consolidation_count = 0
        self.trend_strength_history = []
        
    def start_monitoring(self, entry_price, side, strategy_mode):
        """Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„ØµÙÙ‚Ø©"""
        self.monitoring_active = True
        self.peak_profit = 0
        self.profit_consolidation_count = 0
        self.trend_strength_history = []
        self.last_analysis_time = time.time()
        
        print(f"ğŸ¯ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ù„Ù„ØµÙÙ‚Ø© | Ø§Ù„Ø¬Ø§Ù†Ø¨: {side} | Ø§Ù„Ù†Ù…Ø·: {strategy_mode}")
        
    def stop_monitoring(self):
        """Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©"""
        self.monitoring_active = False
        print("ğŸ›‘ ØªÙˆÙ‚Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ù„Ù„ØµÙÙ‚Ø©")
        
    def intensive_monitoring_cycle(self, df, current_price, side, entry_price, council_data):
        """Ø¯ÙˆØ±Ø© Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…ÙƒØ«ÙØ© ØªØ¹Ù…Ù„ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØµÙÙ‚Ø©"""
        if not self.monitoring_active:
            return {"action": "hold", "reason": "Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ØºÙŠØ± Ù…ÙØ¹Ù„Ø©"}
            
        current_time = time.time()
        if current_time - self.last_analysis_time < self.analysis_interval:
            return {"action": "hold", "reason": "Ù„Ù… ÙŠØ­ÙŠÙ† ÙˆÙ‚Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„"}
            
        self.last_analysis_time = current_time
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠ
        current_profit_pct = (current_price - entry_price) / entry_price * 100 * (1 if side == "long" else -1)
        
        # ØªØ­Ø¯ÙŠØ« Ø°Ø±ÙˆØ© Ø§Ù„Ø±Ø¨Ø­
        if current_profit_pct > self.peak_profit:
            self.peak_profit = current_profit_pct
            self.profit_consolidation_count = 0
        else:
            self.profit_consolidation_count += 1
        
        # ğŸ”¥ ØªØ­Ù„ÙŠÙ„ Ù…ÙƒØ«Ù Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…Ø¬Ù„Ø³
        intensive_analysis = self.comprehensive_position_analysis(
            df, current_price, side, entry_price, current_profit_pct, council_data
        )
        
        return intensive_analysis
    
    def comprehensive_position_analysis(self, df, current_price, side, entry_price, current_profit, council_data):
        """ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ Ù„Ù„ØµÙÙ‚Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…Ø¬Ù„Ø³"""
        analysis_results = {
            "momentum_strength": 0,
            "trend_health": 0,
            "exit_signals": 0,
            "continue_signals": 0,
            "dynamic_targets": [],
            "recommendation": "hold",
            "detailed_reasons": []
        }
        
        # 1. ØªØ­Ù„ÙŠÙ„ Ø²Ø®Ù… Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        momentum_analysis = self.analyze_momentum_strength(df, current_price, side, council_data)
        analysis_results["momentum_strength"] = momentum_analysis["strength"]
        analysis_results["detailed_reasons"].extend(momentum_analysis["reasons"])
        
        # 2. ØªØ­Ù„ÙŠÙ„ ØµØ­Ø© Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        trend_analysis = self.analyze_trend_health(df, side, council_data)
        analysis_results["trend_health"] = trend_analysis["health_score"]
        analysis_results["detailed_reasons"].extend(trend_analysis["reasons"])
        
        # 3. ØªØ­Ù„ÙŠÙ„ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø±ÙˆØ¬
        exit_analysis = self.detect_exit_signals(df, current_price, side, current_profit, council_data)
        analysis_results["exit_signals"] = exit_analysis["signal_count"]
        analysis_results["detailed_reasons"].extend(exit_analysis["reasons"])
        
        # 4. ØªØ­Ù„ÙŠÙ„ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±
        continue_analysis = self.detect_continue_signals(df, side, council_data)
        analysis_results["continue_signals"] = continue_analysis["signal_count"]
        analysis_results["detailed_reasons"].extend(continue_analysis["reasons"])
        
        # 5. Ø­Ø³Ø§Ø¨ Ø£Ù‡Ø¯Ø§Ù Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
        dynamic_targets = self.calculate_dynamic_profit_targets(
            current_profit, analysis_results, side, council_data
        )
        analysis_results["dynamic_targets"] = dynamic_targets
        
        # 6. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
        recommendation = self.determine_final_recommendation(analysis_results, current_profit)
        analysis_results["recommendation"] = recommendation
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„
        self.log_intensive_analysis(analysis_results, current_profit)
        
        return analysis_results
    
    def analyze_momentum_strength(self, df, current_price, side, council_data):
        """ØªØ­Ù„ÙŠÙ„ Ù‚ÙˆØ© Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
        strength = 0
        reasons = []
        
        # Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
        advanced_indicators = council_data.get("advanced_indicators", {})
        
        # 1. Ø²Ø®Ù… Ø§Ù„Ø­Ø¬Ù…
        volume_momentum = advanced_indicators.get("volume_momentum", {})
        if volume_momentum.get("trend") == ("bull" if side == "long" else "bear"):
            strength += 2
            reasons.append("Ø²Ø®Ù… Ø­Ø¬Ù… Ù…ÙˆØ¬Ù‡")
        
        # 2. Ø²Ø®Ù… Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        advanced_momentum = advanced_indicators.get("advanced_momentum", {})
        momentum_trend = advanced_momentum.get("trend", "neutral")
        if (side == "long" and "bull" in momentum_trend) or (side == "short" and "bear" in momentum_trend):
            strength += 3 if "strong" in momentum_trend else 2
            reasons.append(f"Ø²Ø®Ù… Ø³Ø¹Ø± {momentum_trend}")
        
        # 3. ØªØ¯ÙÙ‚ Ø§Ù„Ø£Ù…ÙˆØ§Ù„
        money_flow = advanced_indicators.get("money_flow", {})
        if money_flow.get("direction") == "inflow" and side == "long":
            strength += 2
            reasons.append("ØªØ¯ÙÙ‚ Ø£Ù…ÙˆØ§Ù„ Ø¥ÙŠØ¬Ø§Ø¨ÙŠ")
        elif money_flow.get("direction") == "outflow" and side == "short":
            strength += 2
            reasons.append("ØªØ¯ÙÙ‚ Ø£Ù…ÙˆØ§Ù„ Ø³Ù„Ø¨ÙŠ")
        
        # 4. ØªØ­Ù„ÙŠÙ„ Footprint
        footprint = advanced_indicators.get("footprint", {})
        if footprint.get("ok"):
            if (side == "long" and footprint.get("real_momentum_bullish")) or \
               (side == "short" and footprint.get("real_momentum_bearish")):
                strength += 3
                reasons.append("Ø§Ù†Ø¯ÙØ§Ø¹ Ø­Ù‚ÙŠÙ‚ÙŠ ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡")
        
        return {"strength": strength, "reasons": reasons}
    
    def analyze_trend_health(self, df, side, council_data):
        """ØªØ­Ù„ÙŠÙ„ ØµØ­Ø© Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        health_score = 0
        reasons = []
        
        ind = council_data.get("ind", {})
        advanced_indicators = council_data.get("advanced_indicators", {})
        
        # 1. Ù‚ÙˆØ© ADX
        adx = ind.get('adx', 0)
        if adx > 30:
            health_score += 3
            reasons.append(f"ADX Ù‚ÙˆÙŠ: {adx:.1f}")
        elif adx > 25:
            health_score += 2
            reasons.append(f"ADX Ø¬ÙŠØ¯: {adx:.1f}")
        elif adx > 20:
            health_score += 1
            reasons.append(f"ADX Ù…Ù‚Ø¨ÙˆÙ„: {adx:.1f}")
        
        # 2. Ù…Ø­Ø§Ø°Ø§Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª
        trend_indicator = advanced_indicators.get("trend_indicator", {})
        trend = trend_indicator.get("trend", "neutral")
        if (side == "long" and "bull" in trend) or (side == "short" and "bear" in trend):
            health_score += 2
            reasons.append(f"Ø§ØªØ¬Ø§Ù‡ ØªÙ‚Ù†ÙŠ: {trend}")
        
        # 3. ØªØ£ÙƒÙŠØ¯ SMC
        smc_data = advanced_indicators.get("smc_analysis", {})
        market_structure = smc_data.get("market_structure", {})
        if market_structure.get("trend") == ("bullish" if side == "long" else "bearish"):
            health_score += 3
            reasons.append("ØªØ£ÙƒÙŠØ¯ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚")
        
        # 4. Ø²Ø®Ù… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø·Ø±Ø§Ù
        multi_tf = advanced_indicators.get("multi_timeframe_trend", {})
        alignment = multi_tf.get("alignment", "neutral")
        if (side == "long" and "bull" in alignment) or (side == "short" and "bear" in alignment):
            health_score += 2
            reasons.append(f"Ù…Ø­Ø§Ø°Ø§Ø© Ù…ØªØ¹Ø¯Ø¯Ø©: {alignment}")
        
        return {"health_score": health_score, "reasons": reasons}
    
    def detect_exit_signals(self, df, current_price, side, current_profit, council_data):
        """ÙƒØ´Ù Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø±ÙˆØ¬ Ø§Ù„Ù…Ø¨ÙƒØ±"""
        signal_count = 0
        reasons = []
        
        advanced_indicators = council_data.get("advanced_indicators", {})
        ind = council_data.get("ind", {})
        
        # 1. Ø§Ù†Ø¹ÙƒØ§Ø³ SMC
        smc_data = advanced_indicators.get("smc_analysis", {})
        market_structure = smc_data.get("market_structure", {})
        
        if (side == "long" and market_structure.get("choch_bearish")) or \
           (side == "short" and market_structure.get("choch_bullish")):
            signal_count += 3
            reasons.append("Ø§Ù†Ø¹ÙƒØ§Ø³ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ (CHoCH)")
        
        # 2. ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ù‚ÙˆÙŠ
        advanced_momentum = advanced_indicators.get("advanced_momentum", {})
        momentum_trend = advanced_momentum.get("trend", "neutral")
        if (side == "long" and momentum_trend == "bearish") or \
           (side == "short" and momentum_trend == "bullish"):
            signal_count += 2
            reasons.append("ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø²Ø®Ù…")
        
        # 3. ØªÙˆØ²ÙŠØ¹ Ø­Ø¬Ù… Ø¹ÙƒØ³ÙŠ
        footprint = advanced_indicators.get("footprint", {})
        if footprint.get("ok"):
            if (side == "long" and footprint.get("absorption_bearish")) or \
               (side == "short" and footprint.get("absorption_bullish")):
                signal_count += 2
                reasons.append("Ø§Ù…ØªØµØ§Øµ Ø¹ÙƒØ³ÙŠ")
        
        # 4. ØªÙ‚Ø§Ø·Ø¹ MACD Ø¹ÙƒØ³ÙŠ
        macd = advanced_indicators.get("macd", {})
        if (side == "long" and macd.get("crossover") == "bearish") or \
           (side == "short" and macd.get("crossover") == "bullish"):
            signal_count += 1
            reasons.append("ØªÙ‚Ø§Ø·Ø¹ MACD Ø¹ÙƒØ³ÙŠ")
        
        # 5. ÙˆØµÙˆÙ„ Ù„Ù‡Ø¯Ù Ù…Ø¹Ù‚ÙˆÙ„ Ù…Ø¹ Ø¥Ø´Ø§Ø±Ø§Øª Ø³Ù„Ø¨ÙŠØ©
        if current_profit > 1.0 and signal_count >= 2:
            signal_count += 2
            reasons.append("Ø±Ø¨Ø­ Ø¬ÙŠØ¯ Ù…Ø¹ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù†Ø¹ÙƒØ§Ø³ Ù…ØªØ¹Ø¯Ø¯Ø©")
        
        return {"signal_count": signal_count, "reasons": reasons}
    
    def detect_continue_signals(self, df, side, council_data):
        """ÙƒØ´Ù Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±"""
        signal_count = 0
        reasons = []
        
        advanced_indicators = council_data.get("advanced_indicators", {})
        
        # 1. ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø²Ø®Ù…
        volume_momentum = advanced_indicators.get("volume_momentum", {})
        if volume_momentum.get("strength", 0) > 2.0:
            signal_count += 2
            reasons.append("Ø²Ø®Ù… Ø­Ø¬Ù… Ù…ØªØ¬Ø¯Ø¯")
        
        # 2. ØªØ£ÙƒÙŠØ¯ Order Blocks Ø¬Ø¯ÙŠØ¯Ø©
        smc_data = advanced_indicators.get("smc_analysis", {})
        order_blocks = smc_data.get("order_blocks", {})
        
        current_price = last_val(df['close'])
        relevant_obs = order_blocks.get("bullish_ob", []) if side == "long" else order_blocks.get("bearish_ob", [])
        for ob in relevant_obs[-2:]:  # Ø£Ø­Ø¯Ø« Order Blocks
            if ob['low'] <= current_price <= ob['high']:
                signal_count += 2
                reasons.append(f"Order Block Ø¯Ø§Ø¹Ù…: Ù‚ÙˆØ© {ob['strength']:.1f}%")
        
        # 3. Ø§Ø³ØªÙ…Ø±Ø§Ø± Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚
        market_structure = smc_data.get("market_structure", {})
        if (side == "long" and market_structure.get("bos_bullish")) or \
           (side == "short" and market_structure.get("bos_bearish")):
            signal_count += 3
            reasons.append("Ù‡ÙŠÙƒÙ„ Ø³ÙˆÙ‚ Ù…Ø³ØªÙ…Ø±")
        
        # 4. ØªØ¯ÙÙ‚ Ø£Ù…ÙˆØ§Ù„ Ù…Ø³ØªÙ…Ø±
        money_flow = advanced_indicators.get("money_flow", {})
        if (side == "long" and money_flow.get("direction") == "inflow") or \
           (side == "short" and money_flow.get("direction") == "outflow"):
            signal_count += 2
            reasons.append("ØªØ¯ÙÙ‚ Ø£Ù…ÙˆØ§Ù„ Ù…Ø³ØªÙ…Ø±")
        
        return {"signal_count": signal_count, "reasons": reasons}
    
    def calculate_dynamic_profit_targets(self, current_profit, analysis_results, side, council_data):
        """Ø­Ø³Ø§Ø¨ Ø£Ù‡Ø¯Ø§Ù Ø±Ø¨Ø­ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        base_targets = []
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø­Ø³Ø¨ Ù‚ÙˆØ© Ø§Ù„ØªØ­Ù„ÙŠÙ„
        momentum_strength = analysis_results["momentum_strength"]
        trend_health = analysis_results["trend_health"]
        continue_signals = analysis_results["continue_signals"]
        
        total_bullish_score = momentum_strength + trend_health + continue_signals
        max_possible_score = 20  # ØªÙ‚Ø¯ÙŠØ± Ø£Ù‚ØµÙ‰ Ø¯Ø±Ø¬Ø©
        
        confidence_ratio = total_bullish_score / max_possible_score
        
        # Ø£Ù‡Ø¯Ø§Ù Ù…Ø±Ù†Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø«Ù‚Ø©
        if confidence_ratio > 0.7:  # Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©
            base_targets = [
                current_profit + 0.3,  # Ù‡Ø¯Ù ÙÙˆØ±ÙŠ
                current_profit + 0.8,  # Ù‡Ø¯Ù Ù…ØªÙˆØ³Ø·
                current_profit + 1.5,  # Ù‡Ø¯Ù Ø·Ù…ÙˆØ­
                current_profit + 2.5   # Ù‡Ø¯Ù Ø§Ø³ØªØ«Ù†Ø§Ø¦ÙŠ
            ]
        elif confidence_ratio > 0.5:  # Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©
            base_targets = [
                current_profit + 0.2,
                current_profit + 0.6,
                current_profit + 1.2,
                current_profit + 2.0
            ]
        else:  # Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©
            base_targets = [
                current_profit + 0.1,
                current_profit + 0.4,
                current_profit + 0.8,
                current_profit + 1.5
            ]
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¤Ø´Ø±Ø§Øª SMC
        smc_data = council_data.get("advanced_indicators", {}).get("smc_analysis", {})
        if smc_data.get("market_structure", {}).get("bos_bullish" if side == "long" else "bos_bearish"):
            base_targets = [t * 1.3 for t in base_targets]  # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ù…Ø¹ BOS
        
        return [max(0.2, t) for t in base_targets]  # Ø¶Ù…Ø§Ù† Ø£Ù‡Ø¯Ø§Ù Ù…ÙˆØ¬Ø¨Ø©
    
    def determine_final_recommendation(self, analysis_results, current_profit):
        """ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©"""
        exit_signals = analysis_results["exit_signals"]
        continue_signals = analysis_results["continue_signals"]
        momentum_strength = analysis_results["momentum_strength"]
        
        # Ù‚Ø±Ø§Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
        if exit_signals >= 4:
            return "close_immediate"
        elif exit_signals >= 3 and current_profit > 0.5:
            return "close_aggressive"
        elif exit_signals >= 2 and continue_signals <= 1 and current_profit > 0.8:
            return "close_moderate"
        elif continue_signals >= 3 and momentum_strength >= 5:
            return "continue_strong"
        elif continue_signals >= 2:
            return "continue_moderate"
        else:
            return "hold"
    
    def log_intensive_analysis(self, analysis_results, current_profit):
        """ØªØ³Ø¬ÙŠÙ„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…ÙƒØ«Ù"""
        print(f"\nğŸ” Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªÙØµÙŠÙ„ÙŠ Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø°ÙƒÙŠØ©:", flush=True)
        print(f"ğŸ’° Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_profit:.2f}%", flush=True)
        print(f"ğŸ’ª Ù‚ÙˆØ© Ø§Ù„Ø²Ø®Ù…: {analysis_results['momentum_strength']}/10", flush=True)
        print(f"â¤ï¸ ØµØ­Ø© Ø§Ù„Ø§ØªØ¬Ø§Ù‡: {analysis_results['trend_health']}/10", flush=True)
        print(f"ğŸš¨ Ø¥Ø´Ø§Ø±Ø§Øª Ø®Ø±ÙˆØ¬: {analysis_results['exit_signals']}", flush=True)
        print(f"âœ… Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ø³ØªÙ…Ø±Ø§Ø±: {analysis_results['continue_signals']}", flush=True)
        print(f"ğŸ¯ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©: {analysis_results['dynamic_targets']}", flush=True)
        print(f"ğŸ“‹ Ø§Ù„ØªÙˆØµÙŠØ©: {analysis_results['recommendation']}", flush=True)
        
        if analysis_results['detailed_reasons']:
            print(f"ğŸ“Š Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨: {', '.join(analysis_results['detailed_reasons'])}", flush=True)
        
        print("â”€" * 80, flush=True)

class AdvancedProfitManager:
    def __init__(self):
        self.profit_targets = []
        self.trail_started = False
        self.peak_price = 0
        self.dynamic_trailing = False
        
    def calculate_dynamic_targets(self, df, entry_price, side, mode, atr, council_confidence):
        """Ø­Ø³Ø§Ø¨ Ø£Ù‡Ø¯Ø§Ù Ø±Ø¨Ø­ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚"""
        current_price = last_val(df['close'])
        price_move = abs(current_price - entry_price) / entry_price * 100
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ù†Ù…Ø·
        if mode == "trend":
            base_targets = [0.8, 1.5, 2.5, 4.0]
            base_fractions = [0.20, 0.25, 0.25, 0.30]
        else:  # scalp
            base_targets = [0.4, 0.8, 1.2, 2.0]
            base_fractions = [0.25, 0.30, 0.25, 0.20]
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø«Ù‚Ø© Ø§Ù„Ù…Ø¬Ù„Ø³
        confidence_multiplier = 0.8 + (council_confidence * 0.4)  # 0.8 Ø¥Ù„Ù‰ 1.2
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ‚Ù„Ø¨Ø§Øª
        volatility = df['close'].pct_change().tail(20).std() * 100
        volatility_multiplier = 0.7 + (volatility * 0.3)  # 0.7 Ø¥Ù„Ù‰ 1.3
        
        # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø¶Ø§Ø¹ÙØ§Øª
        adjusted_targets = []
        for target in base_targets:
            adjusted = target * confidence_multiplier * volatility_multiplier
            adjusted_targets.append(round(adjusted, 2))
            
        adjusted_fractions = base_fractions
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ BOS Ù‚ÙˆÙŠØŒ Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
        smc_data = detect_market_structure(df)
        if smc_data.get("bos_bullish") or smc_data.get("bos_bearish"):
            adjusted_targets = [t * 1.3 for t in adjusted_targets]
            
        return {
            "targets": adjusted_targets,
            "fractions": adjusted_fractions,
            "confidence_multiplier": confidence_multiplier,
            "volatility_multiplier": volatility_multiplier
        }
    
    def should_take_profit(self, current_pnl, targets_achieved, current_targets, 
                          df, side, entry_price, council_data):
        """ØªØ­Ø¯ÙŠØ¯ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ¬Ø¨ Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­"""
        if targets_achieved >= len(current_targets):
            return False, "ÙƒÙ„ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ØªÙ… ØªØ­Ù‚ÙŠÙ‚Ù‡Ø§"
            
        next_target = current_targets[targets_achieved]
        
        # Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ù‡Ø¯Ù Ø§Ù„ØªØ§Ù„ÙŠ
        if current_pnl >= next_target:
            return True, f"ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù‡Ø¯Ù {targets_achieved + 1} Ø¹Ù†Ø¯ {next_target}%"
            
        # Ø¬Ù†ÙŠ Ø£Ø±Ø¨Ø§Ø­ Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ Ø¹Ù†Ø¯ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³
        if self._detect_early_reversal_signals(df, side, current_pnl, council_data):
            return True, "Ø¬Ù†ÙŠ Ø£Ø±Ø¨Ø§Ø­ Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ Ø¹Ù†Ø¯ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù†Ø¹ÙƒØ§Ø³"
            
        return False, "Ù„Ù… ÙŠØªØ­Ù‚Ù‚ Ø§Ù„Ù‡Ø¯Ù Ø¨Ø¹Ø¯"
    
    def _detect_early_reversal_signals(self, df, side, current_pnl, council_data):
        """ÙƒØ´Ù Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³ Ø§Ù„Ù…Ø¨ÙƒØ±"""
        if current_pnl < 0.5:  # ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±Ø¨Ø­ Ù…Ø¹Ù‚ÙˆÙ„
            return False
            
        reversal_signals = 0
        
        # ØªØ­Ù„ÙŠÙ„ SMC Ù„Ù„Ø§Ù†Ø¹ÙƒØ§Ø³
        smc_data = council_data.get("advanced_indicators", {}).get("smc_analysis", {})
        market_structure = smc_data.get("market_structure", {})
        
        # CHoCH ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¹Ø§ÙƒØ³
        if side == "long" and market_structure.get("choch_bearish"):
            reversal_signals += 2
        elif side == "short" and market_structure.get("choch_bullish"):
            reversal_signals += 2
            
        # ÙÙ‚Ø¯Ø§Ù† Ø²Ø®Ù… Ù‚ÙˆÙŠ
        momentum = compute_advanced_momentum(df)
        if (side == "long" and momentum["trend"] == "bearish") or \
           (side == "short" and momentum["trend"] == "bullish"):
            reversal_signals += 1
            
        # ØªÙˆØ²ÙŠØ¹ Ø­Ø¬Ù… Ø³Ù„Ø¨ÙŠ
        footprint = advanced_footprint_analysis(df, last_val(df['close']))
        if footprint.get("ok"):
            if (side == "long" and footprint.get("absorption_bearish")) or \
               (side == "short" and footprint.get("absorption_bullish")):
                reversal_signals += 1
                
        return reversal_signals >= 2  # Ø¥Ø´Ø§Ø±ØªØ§Ù† Ø§Ù†Ø¹ÙƒØ§Ø³ÙŠØªØ§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„

# Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø® Ù…Ù† Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
smart_patience = SmartPatienceSystem()
position_monitor = IntelligentPositionMonitor()
profit_manager = AdvancedProfitManager()

# =================== PROFESSIONAL LOGGING ===================
def log_i(msg): print(f"â„¹ï¸ {msg}", flush=True)
def log_g(msg): print(f"âœ… {msg}", flush=True)
def log_w(msg): print(f"ğŸŸ¨ {msg}", flush=True)
def log_e(msg): print(f"âŒ {msg}", flush=True)

def log_banner(text): print(f"\n{'â€”'*12} {text} {'â€”'*12}\n", flush=True)

def save_state(state: dict):
    try:
        state["ts"] = int(time.time())
        with open(STATE_PATH, "w", encoding="utf-8") as f:
            json.dump(state, f, ensure_ascii=False, indent=2)
        log_i(f"state saved â†’ {STATE_PATH}")
    except Exception as e:
        log_w(f"state save failed: {e}")

def load_state() -> dict:
    try:
        if not os.path.exists(STATE_PATH): return {}
        with open(STATE_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        log_w(f"state load failed: {e}")
    return {}

# =================== EXCHANGE FACTORY ===================
def make_ex():
    """Factory function for BingX exchange"""
    exchange_config = {
        "apiKey": API_KEY,
        "secret": API_SECRET,
        "enableRateLimit": True,
        "timeout": 20000,
        "options": {
            "defaultType": "swap",
            "adjustForTimeDifference": True,
            "recvWindow": 60000
        }
    }
    return ccxt.bingx(exchange_config)

ex = make_ex()

# =================== EXCHANGE-SPECIFIC ADAPTERS ===================
def exchange_specific_params(side, is_close=False):
    """Handle BingX specific parameters"""
    return {"positionSide": "LONG" if side == "buy" else "SHORT", "reduceOnly": is_close}

def exchange_set_leverage(exchange, leverage, symbol):
    """BingX leverage setting"""
    try:
        exchange.set_leverage(leverage, symbol, params={"side": "BOTH"})
        log_g(f"âœ… BINGX leverage set: {leverage}x")
    except Exception as e:
        log_w(f"âš ï¸ set_leverage warning: {e}")

def exchange_set_margin_mode(exchange, symbol, margin_mode="isolated"):
    """Set margin mode to isolated"""
    try:
        if hasattr(exchange, 'set_margin_mode'):
            exchange.set_margin_mode(margin_mode, symbol)
            log_g(f"âœ… BINGX margin mode set: {margin_mode}")
    except Exception as e:
        log_w(f"âš ï¸ set_margin_mode warning: {e}")

# =================== MARKET SPECS ===================
MARKET = {}
AMT_PREC = 0
LOT_STEP = None
LOT_MIN  = None

def load_market_specs():
    global MARKET, AMT_PREC, LOT_STEP, LOT_MIN
    try:
        ex.load_markets()
        MARKET = ex.markets.get(SYMBOL, {})
        
        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¯Ù‚Ø© ÙˆØ§Ù„Ø­Ø¯ÙˆØ¯ Ø¨Ø£Ù…Ø§Ù†
        precision_info = MARKET.get("precision", {}) or {}
        limits_info = MARKET.get("limits", {}) or {}
        amount_limits = limits_info.get("amount", {}) or {}
        
        AMT_PREC = int(precision_info.get("amount", 3) or 3)
        
        # ØªØ­ÙˆÙŠÙ„ LOT_STEP Ùˆ LOT_MIN Ø¥Ù„Ù‰ float Ø¨Ø£Ù…Ø§Ù†
        lot_step_raw = amount_limits.get("step", 0.01)
        lot_min_raw = amount_limits.get("min", 0.01)
        
        try:
            LOT_STEP = float(lot_step_raw)
        except (TypeError, ValueError):
            LOT_STEP = 0.01
            
        try:
            LOT_MIN = float(lot_min_raw)
        except (TypeError, ValueError):
            LOT_MIN = 0.01
            
        log_i(f"ğŸ¯ {SYMBOL} specs â†’ precision={AMT_PREC}, step={LOT_STEP}, min={LOT_MIN}")
        
    except Exception as e:
        log_w(f"load_market_specs: {e}")
        # Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¢Ù…Ù†Ø© Ù„Ù„Ø°Ù‡Ø¨
        AMT_PREC = 3
        LOT_STEP = 0.01
        LOT_MIN = 0.01

def ensure_leverage_mode():
    try:
        # Set isolated margin mode first
        exchange_set_margin_mode(ex, SYMBOL, "isolated")
        # Then set leverage
        exchange_set_leverage(ex, LEVERAGE, SYMBOL)
        log_i(f"ğŸ“Š BINGX position mode: {POSITION_MODE} | Margin: ISOLATED")
    except Exception as e:
        log_w(f"ensure_leverage_mode: {e}")

def verify_symbol():
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø² ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…ØªØ§Ø­Ø©"""
    try:
        ex.load_markets()
        log_i(f"âœ… Exchange loaded successfully")
        
        # Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…ØªØ§Ø­Ø© Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ XAU
        xau_symbols = [sym for sym in ex.markets.keys() if 'XAU' in sym or 'GOLD' in sym]
        log_i(f"ğŸ“‹ Available XAU symbols: {xau_symbols}")
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ù…Ø­Ø¯Ø¯
        if SYMBOL in ex.markets:
            log_g(f"âœ… Symbol {SYMBOL} is valid and available")
            return True
        else:
            log_e(f"âŒ Symbol {SYMBOL} not found in available markets")
            log_w(f"ğŸ”„ Trying alternative symbol formats...")
            
            # Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø¨Ø¯ÙŠÙ„Ø©
            alternatives = ["XAUUSDT", "XAU_USDT", "GOLD-USDT", "XAU-USDT"]
            for alt in alternatives:
                if alt in ex.markets:
                    log_g(f"âœ… Alternative symbol found: {alt}")
                    return alt
            
            return False
            
    except Exception as e:
        log_e(f"âŒ Symbol verification failed: {e}")
        return False

# Initialize exchange
try:
    load_market_specs()
    ensure_leverage_mode()
except Exception as e:
    log_w(f"exchange init: {e}")

# =================== CANDLES MODULE ===================
def _body(o,c): return abs(c-o)
def _rng(h,l):  return max(h-l, 1e-12)
def _upper_wick(h,o,c): return h - max(o,c)
def _lower_wick(l,o,c): return min(o,c) - l

def _is_doji(o,c,h,l,th=0.1):
    return _body(o,c) <= th * _rng(h,l)

def _engulfing(po,pc,o,c, min_ratio=1.05):
    bull = (c>o) and (pc<po) and _body(po,pc)>0 and _body(o,c)>=min_ratio*_body(po,pc) and (o<=pc and c>=po)
    bear = (c<o) and (pc>po) and _body(po,pc)>0 and _body(o,c)>=min_ratio*_body(po,pc) and (o>=pc and c<=po)
    return bull, bear

def _hammer_like(o,c,h,l, body_max=0.35, wick_ratio=2.0):
    rng, body = _rng(h,l), _body(o,c)
    lower, upper = _lower_wick(l,o,c), _upper_wick(h,o,c)
    hammer  = (body/rng<=body_max) and (lower>=wick_ratio*body) and (upper<=0.4*body)
    inv_ham = (body/rng<=body_max) and (upper>=wick_ratio*body) and (lower<=0.4*body)
    return hammer, inv_ham

def _shooting_star(o,c,h,l, body_max=0.35, wick_ratio=2.0):
    rng, body = _rng(h,l), _body(o,c)
    return (body/rng<=body_max) and (_upper_wick(h,o,c)>=wick_ratio*body) and (_lower_wick(l,o,c)<=0.4*body)

def _marubozu(o,c,h,l, min_body=0.9): return _body(o,c)/_rng(h,l) >= min_body
def _piercing(po,pc,o,c, min_pen=0.5): return (pc<po) and (c>o) and (c>(po - min_pen*(po-pc))) and (o<pc)
def _dark_cloud(po,pc,o,c, min_pen=0.5): return (pc>po) and (c<o) and (c<(po + min_pen*(pc-po))) and (o>pc)

def _tweezer(ph,pl,h,l, tol=0.15):
    top = abs(h-ph) <= tol*max(h,ph)
    bot = abs(l-pl) <= tol*max(l,pl)
    return top, bot

def compute_candles(df):
    """
    ÙŠØ±Ø¬Ù‘Ø¹: buy/sell + score Ù„ÙƒÙ„ Ø§ØªØ¬Ø§Ù‡ + ÙØªØ§Ø¦Ù„ ÙƒØ¨ÙŠØ±Ø© (exhaustion) + tags
    """
    if len(df) < 5:
        return {"buy":False,"sell":False,"score_buy":0.0,"score_sell":0.0,
                "wick_up_big":False,"wick_dn_big":False,"doji":False,"pattern":None}

    o1,h1,l1,c1 = float(df["open"].iloc[-2]), float(df["high"].iloc[-2]), float(df["low"].iloc[-2]), float(df["close"].iloc[-2])
    o0,h0,l0,c0 = float(df["open"].iloc[-3]), float(df["high"].iloc[-3]), float(df["low"].iloc[-3]), float(df["close"].iloc[-3])

    strength_b = strength_s = 0.0
    tags = []

    bull_eng, bear_eng = _engulfing(o0,c0,o1,c1)
    if bull_eng: strength_b += 2.0; tags.append("bull_engulf")
    if bear_eng: strength_s += 2.0; tags.append("bear_engulf")

    ham, inv = _hammer_like(o1,c1,h1,l1)
    if ham: strength_b += 1.5; tags.append("hammer")
    if inv: strength_s += 1.5; tags.append("inverted_hammer")

    if _shooting_star(o1,c1,h1,l1): strength_s += 1.5; tags.append("shooting_star")
    if _piercing(o0,c0,o1,c1):      strength_b += 1.2; tags.append("piercing")
    if _dark_cloud(o0,c0,o1,c1):    strength_s += 1.2; tags.append("dark_cloud")

    is_doji = _is_doji(o1,c1,h1,l1)
    if is_doji: tags.append("doji")

    tw_top, tw_bot = _tweezer(h0,l0,h1,l1)
    if tw_bot: strength_b += 1.0; tags.append("tweezer_bottom")
    if tw_top: strength_s += 1.0; tags.append("tweezer_top")

    if _marubozu(o1,c1,h1,l1):
        if c1>o1: strength_b += 1.0; tags.append("marubozu_bull")
        else:     strength_s += 1.0; tags.append("marubozu_bear")

    # ÙØªØ§Ø¦Ù„ ÙƒØ¨ÙŠØ±Ø© = Ø¥Ø±Ù‡Ø§Ù‚
    rng1 = _rng(h1,l1); up = _upper_wick(h1,o1,c1); dn = _lower_wick(l1,o1,c1)
    wick_up_big = (up >= 1.2*_body(o1,c1)) and (up >= 0.4*rng1)
    wick_dn_big = (dn >= 1.2*_body(o1,c1)) and (dn >= 0.4*rng1)

    if is_doji:  # ØªØ®ÙÙŠÙ Ø«Ù‚Ø©
        strength_b *= 0.8; strength_s *= 0.8

    return {
        "buy": strength_b>0, "sell": strength_s>0,
        "score_buy": round(strength_b,2), "score_sell": round(strength_s,2),
        "wick_up_big": bool(wick_up_big), "wick_dn_big": bool(wick_dn_big),
        "doji": bool(is_doji), "pattern": ",".join(tags) if tags else None
    }

# =================== EXECUTION VERIFICATION ===================
def verify_execution_environment():
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ¦Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù‚Ù„Ø§Ø¹"""
    print(f"âš™ï¸ EXECUTION ENVIRONMENT", flush=True)
    print(f"ğŸ”§ EXCHANGE: {EXCHANGE_NAME.upper()} | SYMBOL: {SYMBOL}", flush=True)
    print(f"ğŸ”§ EXECUTE_ORDERS: {EXECUTE_ORDERS} | DRY_RUN: {DRY_RUN}", flush=True)
    print(f"ğŸ¯ PROFESSIONAL COUNCIL: min_confidence={ULTIMATE_MIN_CONFIDENCE}", flush=True)
    print(f"ğŸ“ˆ ADVANCED INDICATORS: SMC + MACD + VWAP + Volume Momentum", flush=True)
    print(f"ğŸ‘£ SMART MONEY CONCEPTS: BOS + Order Blocks + FVG + Liquidity Analysis", flush=True)
    print(f"âš¡ RF SETTINGS: period={RF_PERIOD} | mult={RF_MULT} (XAU Optimized)", flush=True)
    print(f"ğŸ’° CAPITAL MANAGEMENT: {int(RISK_ALLOC*100)}% allocation | {LEVERAGE}x leverage", flush=True)
    print(f"ğŸ›¡ï¸ MARGIN MODE: ISOLATED | POSITION MODE: {POSITION_MODE}", flush=True)
    print(f"ğŸš€ ENHANCED SYSTEMS: Smart Patience + Intelligent Monitoring + Advanced Profit Management", flush=True)
    
    if not EXECUTE_ORDERS:
        print("ğŸŸ¡ WARNING: EXECUTE_ORDERS=False - Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙÙ‚Ø·!", flush=True)
    if DRY_RUN:
        print("ğŸŸ¡ WARNING: DRY_RUN=True - Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©!", flush=True)

# =================== ENHANCED INDICATORS ===================
def sma(series, n: int):
    return series.rolling(n, min_periods=1).mean()

def compute_rsi(close, n: int = 14):
    delta = close.diff()
    up = delta.clip(lower=0)
    down = (-delta).clip(lower=0)
    roll_up = up.ewm(span=n, adjust=False).mean()
    roll_down = down.ewm(span=n, adjust=False).mean()
    rs = roll_up / roll_down.replace(0, 1e-12)
    rsi = 100 - (100/(1+rs))
    return rsi.fillna(50)

def rsi_ma_context(df):
    if len(df) < max(RSI_MA_LEN, 14):
        return {"rsi": 50, "rsi_ma": 50, "cross": "none", "trendZ": "none", "in_chop": True}
    
    rsi = compute_rsi(df['close'].astype(float), 14)
    rsi_ma = sma(rsi, RSI_MA_LEN)
    
    cross = "none"
    if len(rsi) >= 2:
        if (safe_iloc(rsi, -2) <= safe_iloc(rsi_ma, -2)) and (safe_iloc(rsi) > safe_iloc(rsi_ma)):
            cross = "bull"
        elif (safe_iloc(rsi, -2) >= safe_iloc(rsi_ma, -2)) and (safe_iloc(rsi) < safe_iloc(rsi_ma)):
            cross = "bear"
    
    above = (rsi > rsi_ma)
    below = (rsi < rsi_ma)
    persist_bull = above.tail(RSI_TREND_PERSIST).all() if len(above) >= RSI_TREND_PERSIST else False
    persist_bear = below.tail(RSI_TREND_PERSIST).all() if len(below) >= RSI_TREND_PERSIST else False
    
    current_rsi = safe_iloc(rsi)
    in_chop = RSI_NEUTRAL_BAND[0] <= current_rsi <= RSI_NEUTRAL_BAND[1]
    
    return {
        "rsi": current_rsi,
        "rsi_ma": safe_iloc(rsi_ma),
        "cross": cross,
        "trendZ": "bull" if persist_bull else ("bear" if persist_bear else "none"),
        "in_chop": in_chop
    }

# =================== SMART MONEY CONCEPTS (SMC) ===================
def detect_liquidity_zones(df, window=20):
    """Ø§ÙƒØªØ´Ø§Ù Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (Liquidity Pools)"""
    if len(df) < window * 2:
        return {"buy_liquidity": [], "sell_liquidity": []}
    
    high = df['high'].astype(float)
    low = df['low'].astype(float)
    volume = df['volume'].astype(float)
    
    # Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù‚Ù…Ù… ÙˆØ§Ù„Ù‚ÙŠØ¹Ø§Ù† Ø§Ù„Ù‡Ø§Ù…Ø©
    resistance_levels = []
    support_levels = []
    
    for i in range(window, len(df) - window):
        # Ù‚Ù…Ù…
        if (high.iloc[i] == high.iloc[i-window:i+window].max() and 
            high.iloc[i] > high.iloc[i-1] and 
            high.iloc[i] > high.iloc[i+1]):
            resistance_levels.append({
                'price': high.iloc[i],
                'strength': volume.iloc[i],
                'time': df['time'].iloc[i]
            })
        
        # Ù‚ÙŠØ¹Ø§Ù†
        if (low.iloc[i] == low.iloc[i-window:i+window].min() and 
            low.iloc[i] < low.iloc[i-1] and 
            low.iloc[i] < low.iloc[i+1]):
            support_levels.append({
                'price': low.iloc[i],
                'strength': volume.iloc[i],
                'time': df['time'].iloc[i]
            })
    
    return {
        "buy_liquidity": sorted(support_levels, key=lambda x: x['price'])[-5:],  # Ø¢Ø®Ø± 5 Ù…Ø³ØªÙˆÙŠØ§Øª Ø¯Ø¹Ù…
        "sell_liquidity": sorted(resistance_levels, key=lambda x: x['price'])[:5]  # Ø¢Ø®Ø± 5 Ù…Ø³ØªÙˆÙŠØ§Øª Ù…Ù‚Ø§ÙˆÙ…Ø©
    }

def detect_fvg(df, threshold=0.1):
    """Ø§ÙƒØªØ´Ø§Ù Fair Value Gaps (FVG)"""
    if len(df) < 3:
        return {"bullish_fvg": [], "bearish_fvg": []}
    
    fvg_bullish = []
    fvg_bearish = []
    
    for i in range(1, len(df) - 1):
        current_low = float(df['low'].iloc[i])
        current_high = float(df['high'].iloc[i])
        prev_high = float(df['high'].iloc[i-1])
        prev_low = float(df['low'].iloc[i-1])
        next_high = float(df['high'].iloc[i+1])
        next_low = float(df['low'].iloc[i+1])
        
        # FVG ØµØ§Ø¹Ø¯: Ù‚Ø§Ø¹ Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© > Ù‚Ù…Ø© Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        if current_low > prev_high and (current_low - prev_high) / current_low >= threshold/100:
            fvg_bullish.append({
                'low': prev_high,
                'high': current_low,
                'strength': (current_low - prev_high) / current_low * 100,
                'time': df['time'].iloc[i]
            })
        
        # FVG Ù‡Ø§Ø¨Ø·: Ù‚Ù…Ø© Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© < Ù‚Ø§Ø¹ Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        if current_high < prev_low and (prev_low - current_high) / prev_low >= threshold/100:
            fvg_bearish.append({
                'low': current_high,
                'high': prev_low,
                'strength': (prev_low - current_high) / prev_low * 100,
                'time': df['time'].iloc[i]
            })
    
    return {
        "bullish_fvg": fvg_bullish[-3:],  # Ø¢Ø®Ø± 3 FVG ØµØ§Ø¹Ø¯Ø©
        "bearish_fvg": fvg_bearish[-3:]   # Ø¢Ø®Ø± 3 FVG Ù‡Ø§Ø¨Ø·Ø©
    }

def detect_market_structure(df):
    """ØªØ­Ù„ÙŠÙ„ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ (Market Structure)"""
    if len(df) < 20:
        return {"trend": "neutral", "bos_bullish": False, "bos_bearish": False, 
                "choch_bullish": False, "choch_bearish": False, "liquidity_sweep": False}
    
    high = df['high'].astype(float)
    low = df['low'].astype(float)
    close = df['close'].astype(float)
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    higher_highs = high.rolling(5).apply(lambda x: x[-1] > x[-2] and x[-2] > x[-3], raw=True).fillna(0)
    higher_lows = low.rolling(5).apply(lambda x: x[-1] > x[-2] and x[-2] > x[-3], raw=True).fillna(0)
    lower_highs = high.rolling(5).apply(lambda x: x[-1] < x[-2] and x[-2] < x[-3], raw=True).fillna(0)
    lower_lows = low.rolling(5).apply(lambda x: x[-1] < x[-2] and x[-2] < x[-3], raw=True).fillna(0)
    
    # Break of Structure (BOS)
    bos_bullish = False
    bos_bearish = False
    
    if len(df) >= 10:
        # BOS ØµØ§Ø¹Ø¯: Ø§Ø®ØªØ±Ø§Ù‚ Ø£Ø¹Ù„Ù‰ Ù‚Ù…Ø© Ø³Ø§Ø¨Ù‚Ø©
        recent_high = high.iloc[-10:-1].max()
        bos_bullish = high.iloc[-1] > recent_high
        
        # BOS Ù‡Ø§Ø¨Ø·: Ø§Ø®ØªØ±Ø§Ù‚ Ø£Ø¯Ù†Ù‰ Ù‚Ø§Ø¹ Ø³Ø§Ø¨Ù‚
        recent_low = low.iloc[-10:-1].min()
        bos_bearish = low.iloc[-1] < recent_low
    
    # Change of Character (CHoCH)
    choch_bullish = higher_highs.iloc[-1] and lower_lows.iloc[-1]
    choch_bearish = lower_lows.iloc[-1] and higher_highs.iloc[-1]
    
    # Liquidity Sweep
    liquidity_sweep = False
    if len(df) >= 5:
        # Ù…Ø³Ø­ Ø³ÙŠÙˆÙ„Ø©: Ø­Ø±ÙƒØ© Ø³Ø±ÙŠØ¹Ø© ØªØ¬Ø§Ù‡ Ù…Ø³ØªÙˆÙ‰ Ø«Ù… Ø§Ø±ØªØ¯Ø§Ø¯
        recent_extreme = high.iloc[-5:-1].max() if bos_bullish else low.iloc[-5:-1].min() if bos_bearish else None
        if recent_extreme:
            move_size = abs(close.iloc[-1] - recent_extreme) / recent_extreme * 100
            liquidity_sweep = move_size > 0.5  # Ø­Ø±ÙƒØ© Ø£ÙƒØ«Ø± Ù…Ù† 0.5%
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    if higher_highs.iloc[-1] and higher_lows.iloc[-1]:
        trend = "bullish"
    elif lower_highs.iloc[-1] and lower_lows.iloc[-1]:
        trend = "bearish"
    else:
        trend = "neutral"
    
    return {
        "trend": trend,
        "bos_bullish": bool(bos_bullish),
        "bos_bearish": bool(bos_bearish),
        "choch_bullish": bool(choch_bullish),
        "choch_bearish": bool(choch_bearish),
        "liquidity_sweep": bool(liquidity_sweep)
    }

def detect_order_blocks(df):
    """Ø§ÙƒØªØ´Ø§Ù Order Blocks (OB)"""
    if len(df) < 10:
        return {"bullish_ob": [], "bearish_ob": []}
    
    bullish_ob = []
    bearish_ob = []
    
    for i in range(5, len(df) - 5):
        # Order Block ØµØ§Ø¹Ø¯: Ø´Ù…Ø¹Ø© Ù‡Ø§Ø¨Ø·Ø© ÙƒØ¨ÙŠØ±Ø© ØªÙ„ÙŠÙ‡Ø§ Ø´Ù…Ø¹Ø© ØµØ§Ø¹Ø¯Ø©
        if (df['close'].iloc[i] < df['open'].iloc[i] and  # Ø´Ù…Ø¹Ø© Ù‡Ø§Ø¨Ø·Ø©
            df['close'].iloc[i+1] > df['open'].iloc[i+1] and  # Ø´Ù…Ø¹Ø© ØµØ§Ø¹Ø¯Ø© ØªÙ„ÙŠÙ‡Ø§
            abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i] > OB_STRENGTH_THRESHOLD/100):  # Ø­Ø¬Ù… Ù…Ù†Ø§Ø³Ø¨
            
            bullish_ob.append({
                'high': max(float(df['high'].iloc[i]), float(df['high'].iloc[i+1])),
                'low': min(float(df['low'].iloc[i]), float(df['low'].iloc[i+1])),
                'strength': abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i] * 100,
                'time': df['time'].iloc[i]
            })
        
        # Order Block Ù‡Ø§Ø¨Ø·: Ø´Ù…Ø¹Ø© ØµØ§Ø¹Ø¯Ø© ÙƒØ¨ÙŠØ±Ø© ØªÙ„ÙŠÙ‡Ø§ Ø´Ù…Ø¹Ø© Ù‡Ø§Ø¨Ø·Ø©
        if (df['close'].iloc[i] > df['open'].iloc[i] and  # Ø´Ù…Ø¹Ø© ØµØ§Ø¹Ø¯Ø©
            df['close'].iloc[i+1] < df['open'].iloc[i+1] and  # Ø´Ù…Ø¹Ø© Ù‡Ø§Ø¨Ø·Ø© ØªÙ„ÙŠÙ‡Ø§
            abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i] > OB_STRENGTH_THRESHOLD/100):  # Ø­Ø¬Ù… Ù…Ù†Ø§Ø³Ø¨
            
            bearish_ob.append({
                'high': max(float(df['high'].iloc[i]), float(df['high'].iloc[i+1])),
                'low': min(float(df['low'].iloc[i]), float(df['low'].iloc[i+1])),
                'strength': abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i] * 100,
                'time': df['time'].iloc[i]
            })
    
    return {
        "bullish_ob": bullish_ob[-5:],  # Ø¢Ø®Ø± 5 order blocks ØµØ§Ø¹Ø¯Ø©
        "bearish_ob": bearish_ob[-5:]   # Ø¢Ø®Ø± 5 order blocks Ù‡Ø§Ø¨Ø·Ø©
    }

# =================== ADVANCED INDICATORS - PROFESSIONAL ===================
def compute_macd(df, fast=12, slow=26, signal=9):
    """Ø­Ø³Ø§Ø¨ Ù…Ø¤Ø´Ø± MACD Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    if len(df) < slow + signal:
        return {"macd": 0, "signal": 0, "histogram": 0, "trend": "neutral", "crossover": "none", "above_zero": False}
    
    close = df['close'].astype(float)
    
    ema_fast = close.ewm(span=fast).mean()
    ema_slow = close.ewm(span=slow).mean()
    
    macd_line = ema_fast - ema_slow
    signal_line = macd_line.ewm(span=signal).mean()
    histogram = macd_line - signal_line
    
    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    current_macd = last_val(macd_line)
    current_signal = last_val(signal_line)
    current_hist = last_val(histogram)
    
    # Ø§ØªØ¬Ø§Ù‡ MACD
    if current_macd > current_signal and current_hist > 0:
        trend = "bullish"
    elif current_macd < current_signal and current_hist < 0:
        trend = "bearish"
    else:
        trend = "neutral"
    
    # ØªÙ‚Ø§Ø·Ø¹Ø§Øª
    crossover = "none"
    if len(macd_line) >= 2 and len(signal_line) >= 2:
        if (safe_iloc(macd_line, -2) <= safe_iloc(signal_line, -2) and 
            current_macd > current_signal):
            crossover = "bullish"
        elif (safe_iloc(macd_line, -2) >= safe_iloc(signal_line, -2) and 
              current_macd < current_signal):
            crossover = "bearish"
    
    return {
        "macd": current_macd,
        "signal": current_signal,
        "histogram": current_hist,
        "trend": trend,
        "crossover": crossover,
        "above_zero": current_macd > 0
    }

def compute_vwap(df):
    """Ø­Ø³Ø§Ø¨ VWAP (Volume Weighted Average Price)"""
    if len(df) < 20:
        return {"vwap": 0, "deviation": 0, "signal": "neutral", "price_above_vwap": False}
    
    high = df['high'].astype(float)
    low = df['low'].astype(float)
    close = df['close'].astype(float)
    volume = df['volume'].astype(float)
    
    typical_price = (high + low + close) / 3
    vwap = (typical_price * volume).cumsum() / volume.cumsum()
    
    current_vwap = last_val(vwap)
    current_price = last_val(close)
    deviation = (current_price - current_vwap) / current_vwap * 100
    
    # Ø¥Ø´Ø§Ø±Ø§Øª VWAP
    if deviation > 2.0:
        signal = "overbought"
    elif deviation < -2.0:
        signal = "oversold"
    elif deviation > 0.5:
        signal = "bullish"
    elif deviation < -0.5:
        signal = "bearish"
    else:
        signal = "neutral"
    
    return {
        "vwap": current_vwap,
        "deviation": deviation,
        "signal": signal,
        "price_above_vwap": current_price > current_vwap
    }

def compute_advanced_momentum(df):
    """Ø²Ø®Ù… Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„ØªØ³Ø§Ø±Ø¹"""
    if len(df) < 30:
        return {"momentum": 0, "acceleration": 0, "velocity": 0, "trend": "neutral", "strength": 0}
    
    close = df['close'].astype(float)
    
    # Ø§Ù„Ø³Ø±Ø¹Ø© (Ø§Ù„ØªØºÙŠØ± ÙÙŠ Ø§Ù„Ø³Ø¹Ø±)
    velocity = close.pct_change(5).iloc[-1] * 100
    
    # Ø§Ù„ØªØ³Ø§Ø±Ø¹ (Ø§Ù„ØªØºÙŠØ± ÙÙŠ Ø§Ù„Ø³Ø±Ø¹Ø©)
    acceleration = 0
    if len(close) >= 6:
        acceleration = (close.pct_change(5).iloc[-1] - close.pct_change(5).iloc[-2]) * 100
    
    # Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ù…Ø±Ø¬Ø­ Ø¨Ø§Ù„Ø­Ø¬Ù…
    volume = df['volume'].astype(float)
    volume_weighted_momentum = (close.pct_change(3) * volume.rolling(3).mean()).iloc[-1] * 100
    
    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    if velocity > 0.5 and acceleration > 0.1:
        trend = "strong_bullish"
    elif velocity > 0.2:
        trend = "bullish"
    elif velocity < -0.5 and acceleration < -0.1:
        trend = "strong_bearish"
    elif velocity < -0.2:
        trend = "bearish"
    else:
        trend = "neutral"
    
    return {
        "momentum": volume_weighted_momentum,
        "acceleration": acceleration,
        "velocity": velocity,
        "trend": trend,
        "strength": abs(volume_weighted_momentum)
    }

def enhanced_volume_momentum(df, period=20):
    """Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ø­Ø¬Ù…ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    if len(df) < period + 5:
        return {"trend": "neutral", "strength": 0, "signal": 0}
    
    volume = df['volume'].astype(float)
    close = df['close'].astype(float)
    
    # Ù…ØªÙˆØ³Ø· Ø­Ø¬Ù… Ù…ØªØ­Ø±Ùƒ
    volume_ma = volume.rolling(period).mean()
    volume_ratio = volume / volume_ma.replace(0, 1)
    
    # Ø²Ø®Ù… Ø§Ù„Ø³Ø¹Ø± Ù…Ø¹ Ø§Ù„Ø­Ø¬Ù…
    price_change = close.pct_change(period)
    volume_weighted_momentum = price_change * volume_ratio
    
    current_momentum = last_val(volume_weighted_momentum)
    momentum_trend = "bull" if current_momentum > 0.02 else ("bear" if current_momentum < -0.02 else "neutral")
    
    return {
        "trend": momentum_trend,
        "strength": abs(current_momentum) * 100,
        "signal": current_momentum
    }

def stochastic_rsi_enhanced(df, rsi_period=14, stoch_period=14, k_period=3, d_period=3):
    """Ù…Ø¤Ø´Ø± RSI Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø§Ù„Ù…Ø­Ø³Ù†"""
    if len(df) < max(rsi_period, stoch_period) + 10:
        return {"k": 50, "d": 50, "signal": "neutral", "oversold": False, "overbought": False}
    
    # Ø­Ø³Ø§Ø¨ RSI
    rsi = compute_rsi(df['close'].astype(float), rsi_period)
    
    # Ø­Ø³Ø§Ø¨ Stochastic Ù„Ù„Ù€ RSI
    rsi_low = rsi.rolling(stoch_period).min()
    rsi_high = rsi.rolling(stoch_period).max()
    
    stoch_k = 100 * (rsi - rsi_low) / (rsi_high - rsi_low).replace(0, 100)
    stoch_k_smooth = stoch_k.rolling(k_period).mean()
    stoch_d = stoch_k_smooth.rolling(d_period).mean()
    
    current_k = last_val(stoch_k_smooth)
    current_d = last_val(stoch_d)
    
    # Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„
    signal = "neutral"
    if current_k < 20 and current_d < 20:
        signal = "bullish"
    elif current_k > 80 and current_d > 80:
        signal = "bearish"
    elif current_k > current_d and len(stoch_k_smooth) >= 2 and len(stoch_d) >= 2 and safe_iloc(stoch_k_smooth, -2) <= safe_iloc(stoch_d, -2):
        signal = "bullish_cross"
    elif current_k < current_d and len(stoch_k_smooth) >= 2 and len(stoch_d) >= 2 and safe_iloc(stoch_k_smooth, -2) >= safe_iloc(stoch_d, -2):
        signal = "bearish_cross"
    
    return {
        "k": current_k,
        "d": current_d,
        "signal": signal,
        "oversold": current_k < 20,
        "overbought": current_k > 80
    }

def dynamic_pivot_points(df, period=20):
    """Ù†Ù‚Ø§Ø· Ù…Ø­ÙˆØ±ÙŠØ© Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©"""
    if len(df) < period:
        return {"pivot": 0, "r1": 0, "r2": 0, "s1": 0, "s2": 0, "bias": "neutral"}
    
    high = df['high'].astype(float).tail(period)
    low = df['low'].astype(float).tail(period)
    close = df['close'].astype(float).tail(period)
    
    pivot = (last_val(high) + last_val(low) + last_val(close)) / 3
    r1 = 2 * pivot - last_val(low)
    r2 = pivot + (last_val(high) - last_val(low))
    s1 = 2 * pivot - last_val(high)
    s2 = pivot - (last_val(high) - last_val(low))
    
    current_price = last_val(close)
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø²
    if current_price > r1:
        bias = "strong_bullish"
    elif current_price > pivot:
        bias = "bullish"
    elif current_price < s1:
        bias = "strong_bearish"
    elif current_price < pivot:
        bias = "bearish"
    else:
        bias = "neutral"
    
    return {
        "pivot": pivot,
        "r1": r1, "r2": r2,
        "s1": s1, "s2": s2,
        "bias": bias
    }

def dynamic_trend_indicator(df, fast_period=10, slow_period=20, signal_period=9):
    """Ù…Ø¤Ø´Ø± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ"""
    if len(df) < slow_period + signal_period:
        return {"trend": "neutral", "momentum": 0, "signal": "hold", "ema_fast": 0, "ema_slow": 0}
    
    close = df['close'].ast(float)
    
    # Ù…ØªÙˆØ³Ø·Ø§Øª Ù…ØªØ­Ø±ÙƒØ© Ù…ØªØ¹Ø¯Ø¯Ø©
    ema_fast = close.ewm(span=fast_period).mean()
    ema_slow = close.ewm(span=slow_period).mean()
    ema_signal = ema_fast.ewm(span=signal_period).mean()
    
    # ØªÙ‚Ø§Ø·Ø¹Ø§Øª Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    fast_above_slow = last_val(ema_fast) > last_val(ema_slow)
    fast_above_signal = last_val(ema_fast) > last_val(ema_signal)
    
    # Ø²Ø®Ù… Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    momentum = (last_val(ema_fast) - last_val(ema_slow)) / last_val(ema_slow) * 100
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    if fast_above_slow and fast_above_signal and momentum > 0.1:
        trend = "strong_bull"
    elif fast_above_slow and momentum > 0:
        trend = "bull"
    elif not fast_above_slow and not fast_above_signal and momentum < -0.1:
        trend = "strong_bear"
    elif not fast_above_slow and momentum < 0:
        trend = "bear"
    else:
        trend = "neutral"
    
    # Ø¥Ø´Ø§Ø±Ø© Ø§Ù„ØªØ¯Ø§ÙˆÙ„
    signal = "hold"
    if len(ema_fast) >= 2 and len(ema_slow) >= 2:
        if trend == "strong_bull" and safe_iloc(ema_fast, -2) <= safe_iloc(ema_slow, -2):
            signal = "strong_buy"
        elif trend == "bull" and len(ema_signal) >= 2 and safe_iloc(ema_fast, -2) <= safe_iloc(ema_signal, -2):
            signal = "buy"
        elif trend == "strong_bear" and safe_iloc(ema_fast, -2) >= safe_iloc(ema_slow, -2):
            signal = "strong_sell"
        elif trend == "bear" and len(ema_signal) >= 2 and safe_iloc(ema_fast, -2) >= safe_iloc(ema_signal, -2):
            signal = "sell"
    
    return {
        "trend": trend,
        "momentum": momentum,
        "signal": signal,
        "ema_fast": last_val(ema_fast),
        "ema_slow": last_val(ema_slow)
    }

# =================== ADVANCED FOOTPRINT ANALYSIS ===================
def advanced_footprint_analysis(df, current_price):
    """
    ØªØ­Ù„ÙŠÙ„ Ø¨ØµÙ…Ø© Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„Ø§ÙƒØªØ´Ø§Ù:
    - Ø§Ù„Ø§Ù…ØªØµØ§Øµ (Absorption)
    - Ø§Ù„Ø§Ù†Ø¯ÙØ§Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ (Real Momentum)
    - Ù†Ù‚Ø§Ø· Ø§Ù„ØªÙˆÙ‚Ù (Stops)
    - Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© (Hidden Liquidity)
    """
    if len(df) < FOOTPRINT_PERIOD + 5:
        return {"ok": False, "reason": "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ©"}
    
    try:
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        high = df['high'].astype(float)
        low = df['low'].astype(float)
        close = df['close'].astype(float)
        volume = df['volume'].astype(float)
        open_price = df['open'].astype(float)
        
        # Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª Ø§Ù„Ø­Ø¬Ù…ÙŠØ©
        volume_ma = volume.rolling(FOOTPRINT_PERIOD).mean()
        volume_ratio = volume / volume_ma.replace(0, 1)
        
        # Ø­Ø³Ø§Ø¨ Ø¯Ù„ØªØ§ Ø§Ù„Ø­Ø¬Ù… (Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ø´Ø±Ø§Ø¡ ÙˆØ§Ù„Ø¨ÙŠØ¹)
        up_volume = volume.where(close > open_price, 0)
        down_volume = volume.where(close < open_price, 0)
        volume_delta = (up_volume - down_volume).fillna(0)
        
        # ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø­Ø±ÙƒØ© (Efficiency)
        body_size = abs(close - open_price)
        total_range = high - low
        efficiency = body_size / total_range.replace(0, 1)
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        current_candle = {
            'high': last_val(high),
            'low': last_val(low),
            'close': last_val(close),
            'open': last_val(open_price),
            'volume': last_val(volume),
            'volume_ratio': last_val(volume_ratio),
            'delta': last_val(volume_delta),
            'efficiency': last_val(efficiency)
        }
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ù…ØªØµØ§Øµ
        absorption_bullish = False
        absorption_bearish = False
        
        # Ø§Ù…ØªØµØ§Øµ ØµØ§Ø¹Ø¯: Ø­Ø¬Ù… Ø¹Ø§Ù„ÙŠ + ÙƒÙØ§Ø¡Ø© Ù…Ù†Ø®ÙØ¶Ø© + Ø¯Ù„ØªØ§ Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©
        if (current_candle['volume_ratio'] >= FOOTPRINT_VOLUME_THRESHOLD and
            current_candle['efficiency'] < 0.4 and
            current_candle['delta'] > 0):
            absorption_bullish = True
        
        # Ø§Ù…ØªØµØ§Øµ Ù‡Ø§Ø¨Ø·: Ø­Ø¬Ù… Ø¹Ø§Ù„ÙŠ + ÙƒÙØ§Ø¡Ø© Ù…Ù†Ø®ÙØ¶Ø© + Ø¯Ù„ØªØ§ Ø³Ù„Ø¨ÙŠØ©
        if (current_candle['volume_ratio'] >= FOOTPRINT_VOLUME_THRESHOLD and
            current_candle['efficiency'] < 0.4 and
            current_candle['delta'] < 0):
            absorption_bearish = True
        
        # Ø§Ù†Ø¯ÙØ§Ø¹ Ø­Ù‚ÙŠÙ‚ÙŠ
        real_momentum_bullish = False
        real_momentum_bearish = False
        
        # Ø§Ù†Ø¯ÙØ§Ø¹ ØµØ§Ø¹Ø¯ Ø­Ù‚ÙŠÙ‚ÙŠ: Ø­Ø¬Ù… Ø¹Ø§Ù„ÙŠ + ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ© + Ø¯Ù„ØªØ§ Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©
        if (current_candle['volume_ratio'] >= FOOTPRINT_VOLUME_THRESHOLD and
            current_candle['efficiency'] > EFFICIENCY_THRESHOLD and
            current_candle['delta'] > DELTA_THRESHOLD):
            real_momentum_bullish = True
        
        # Ø§Ù†Ø¯ÙØ§Ø¹ Ù‡Ø§Ø¨Ø· Ø­Ù‚ÙŠÙ‚ÙŠ: Ø­Ø¬Ù… Ø¹Ø§Ù„ÙŠ + ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ© + Ø¯Ù„ØªØ§ Ø³Ù„Ø¨ÙŠØ©
        if (current_candle['volume_ratio'] >= FOOTPRINT_VOLUME_THRESHOLD and
            current_candle['efficiency'] > EFFICIENCY_THRESHOLD and
            current_candle['delta'] < -DELTA_THRESHOLD):
            real_momentum_bearish = True
        
        # Ù†Ù‚Ø§Ø· Ø§Ù„ØªÙˆÙ‚Ù (Stop Hunts)
        stop_hunt_bullish = False
        stop_hunt_bearish = False
        
        # ØµÙŠØ¯ ØªÙˆÙ‚Ù ØµØ§Ø¹Ø¯: Ø­Ø±ÙƒØ© Ø³Ø±ÙŠØ¹Ø© Ù‡Ø§Ø¨Ø·Ø© Ø«Ù… Ø§Ø±ØªØ¯Ø§Ø¯ Ø³Ø±ÙŠØ¹
        if len(df) >= 3:
            prev_low = safe_iloc(low, -2)
            prev_high = safe_iloc(high, -2)
            current_low = current_candle['low']
            current_high = current_candle['high']
            
            # ØµÙŠØ¯ ØªÙˆÙ‚Ù Ù‡Ø§Ø¨Ø·: Ø§Ø®ØªØ±Ø§Ù‚ Ù‚Ø§Ø¹ Ø³Ø§Ø¨Ù‚ Ø«Ù… Ø§Ø±ØªØ¯Ø§Ø¯
            if current_low < prev_low and current_candle['close'] > prev_low:
                stop_hunt_bullish = True
            
            # ØµÙŠØ¯ ØªÙˆÙ‚Ù ØµØ§Ø¹Ø¯: Ø§Ø®ØªØ±Ø§Ù‚ Ù‚Ù…Ø© Ø³Ø§Ø¨Ù‚Ø© Ø«Ù… Ø§Ù†Ù‡ÙŠØ§Ø±
            if current_high > prev_high and current_candle['close'] < prev_high:
                stop_hunt_bearish = True
        
        # ØªØ­Ù„ÙŠÙ„ ØªØ¬Ù…Ø¹Ø§Øª Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (Liquidity Pools)
        liquidity_analysis = analyze_liquidity_pools(df, current_price)
        
        # Ø­Ø³Ø§Ø¨ Ù‚ÙˆØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
        footprint_score_bull = 0.0
        footprint_score_bear = 0.0
        reasons = []
        
        if absorption_bullish:
            footprint_score_bull += 2.5
            reasons.append("Ø§Ù…ØªØµØ§Øµ ØµØ§Ø¹Ø¯ Ù‚ÙˆÙŠ")
        
        if absorption_bearish:
            footprint_score_bear += 2.5
            reasons.append("Ø§Ù…ØªØµØ§Øµ Ù‡Ø§Ø¨Ø· Ù‚ÙˆÙŠ")
        
        if real_momentum_bullish:
            footprint_score_bull += 3.0
            reasons.append("Ø§Ù†Ø¯ÙØ§Ø¹ ØµØ§Ø¹Ø¯ Ø­Ù‚ÙŠÙ‚ÙŠ")
        
        if real_momentum_bearish:
            footprint_score_bear += 3.0
            reasons.append("Ø§Ù†Ø¯ÙØ§Ø¹ Ù‡Ø§Ø¨Ø· Ø­Ù‚ÙŠÙ‚ÙŠ")
        
        if stop_hunt_bullish:
            footprint_score_bull += 2.0
            reasons.append("ØµÙŠØ¯ ØªÙˆÙ‚Ù ØµØ§Ø¹Ø¯")
        
        if stop_hunt_bearish:
            footprint_score_bear += 2.0
            reasons.append("ØµÙŠØ¯ ØªÙˆÙ‚Ù Ù‡Ø§Ø¨Ø·")
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©
        if liquidity_analysis.get('buy_liquidity_above'):
            footprint_score_bull += 1.5
            reasons.append("Ø³ÙŠÙˆÙ„Ø© Ø´Ø±Ø§Ø¡ ÙÙˆÙ‚ Ø§Ù„Ø³Ø¹Ø±")
        
        if liquidity_analysis.get('sell_liquidity_below'):
            footprint_score_bear += 1.5
            reasons.append("Ø³ÙŠÙˆÙ„Ø© Ø¨ÙŠØ¹ ØªØ­Øª Ø§Ù„Ø³Ø¹Ø±")
        
        return {
            "ok": True,
            "absorption_bullish": absorption_bullish,
            "absorption_bearish": absorption_bearish,
            "real_momentum_bullish": real_momentum_bullish,
            "real_momentum_bearish": real_momentum_bearish,
            "stop_hunt_bullish": stop_hunt_bullish,
            "stop_hunt_bearish": stop_hunt_bearish,
            "footprint_score_bull": footprint_score_bull,
            "footprint_score_bear": footprint_score_bear,
            "current_candle": current_candle,
            "liquidity_analysis": liquidity_analysis,
            "reasons": reasons
        }
        
    except Exception as e:
        return {"ok": False, "reason": f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„: {str(e)}"}

def analyze_liquidity_pools(df, current_price):
    """ØªØ­Ù„ÙŠÙ„ ØªØ¬Ù…Ø¹Ø§Øª Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©"""
    if len(df) < 50:
        return {}
    
    try:
        high = df['high'].astype(float)
        low = df['low'].astype(float)
        volume = df['volume'].astype(float)
        
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©)
        lookback = min(100, len(df))
        recent_highs = high.tail(lookback)
        recent_lows = low.tail(lookback)
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        resistance_levels = find_significant_highs(recent_highs)
        support_levels = find_significant_lows(recent_lows)
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø³ÙŠÙˆÙ„Ø©
        buy_liquidity_above = False
        sell_liquidity_below = False
        
        for level in resistance_levels:
            if abs(current_price - level) / current_price <= 0.02:  # Ø¶Ù…Ù† 2%
                sell_liquidity_below = True
                break
        
        for level in support_levels:
            if abs(current_price - level) / current_price <= 0.02:  # Ø¶Ù…Ù† 2%
                buy_liquidity_above = True
                break
        
        return {
            "resistance_levels": resistance_levels[-3:],  # Ø¢Ø®Ø± 3 Ù…Ø³ØªÙˆÙŠØ§Øª Ù…Ù‚Ø§ÙˆÙ…Ø©
            "support_levels": support_levels[-3:],        # Ø¢Ø®Ø± 3 Ù…Ø³ØªÙˆÙŠØ§Øª Ø¯Ø¹Ù…
            "buy_liquidity_above": buy_liquidity_above,
            "sell_liquidity_below": sell_liquidity_below
        }
        
    except Exception as e:
        return {}

def find_significant_highs(series, window=5):
    """Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù‚Ù…Ù… Ø§Ù„Ù‡Ø§Ù…Ø©"""
    highs = []
    for i in range(window, len(series) - window):
        if (series.iloc[i] == series.iloc[i-window:i+window].max() and 
            series.iloc[i] > series.iloc[i-1] and 
            series.iloc[i] > series.iloc[i+1]):
            highs.append(series.iloc[i])
    return highs

def find_significant_lows(series, window=5):
    """Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù‚ÙŠØ¹Ø§Ù† Ø§Ù„Ù‡Ø§Ù…Ø©"""
    lows = []
    for i in range(window, len(series) - window):
        if (series.iloc[i] == series.iloc[i-window:i+window].min() and 
            series.iloc[i] < series.iloc[i-1] and 
            series.iloc[i] < series.iloc[i+1]):
            lows.append(series.iloc[i])
    return lows

# =================== ENHANCED STRATEGY MODE DETECTION ===================
def enhanced_strategy_mode_detection(df, council_data):
    """ÙƒØ´Ù Ù…ØªÙ‚Ø¯Ù… Ù„Ù†Ù…Ø· Ø§Ù„ØªØ¯Ø§ÙˆÙ„: Ø³ÙƒØ§Ù„Ø¨ vs ØªØ±Ù†Ø¯"""
    if len(df) < 50:
        return {"mode": "scalp", "confidence": 0.5, "reasons": ["insufficient_data"]}
    
    current_price = last_val(df['close'])
    ind = compute_indicators(df)
    smc_data = council_data.get("advanced_indicators", {}).get("smc_analysis", {})
    
    # Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    factors = {
        "adx_strength": 0,
        "rsi_trend": 0,
        "volume_momentum": 0,
        "market_structure": 0,
        "macd_trend": 0,
        "vwap_alignment": 0,
        "smc_confirmation": 0
    }
    
    # 1. Ù‚ÙˆØ© ADX
    adx = ind.get('adx', 0)
    di_plus = ind.get('plus_di', 0)
    di_minus = ind.get('minus_di', 0)
    di_spread = abs(di_plus - di_minus)
    
    if adx > 30 and di_spread > 12:
        factors["adx_strength"] = 3
    elif adx > 25 and di_spread > 8:
        factors["adx_strength"] = 2
    elif adx > 20:
        factors["adx_strength"] = 1
        
    # 2. Ø§ØªØ¬Ø§Ù‡ RSI
    rsi_ctx = rsi_ma_context(df)
    if rsi_ctx["trendZ"] == "bull" and rsi_ctx["rsi"] > 60:
        factors["rsi_trend"] = 2
    elif rsi_ctx["trendZ"] == "bear" and rsi_ctx["rsi"] < 40:
        factors["rsi_trend"] = 2
    elif not rsi_ctx["in_chop"]:
        factors["rsi_trend"] = 1
        
    # 3. Ø²Ø®Ù… Ø§Ù„Ø­Ø¬Ù…
    volume_momentum = enhanced_volume_momentum(df)
    if volume_momentum["strength"] > 3.0 and volume_momentum["trend"] != "neutral":
        factors["volume_momentum"] = 2
    elif volume_momentum["strength"] > 1.5:
        factors["volume_momentum"] = 1
        
    # 4. Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù…Ù† SMC
    market_structure = smc_data.get("market_structure", {})
    if market_structure.get("bos_bullish") or market_structure.get("bos_bearish"):
        factors["market_structure"] = 3
    elif market_structure.get("trend") in ["bullish", "bearish"]:
        factors["market_structure"] = 2
        
    # 5. Ø§ØªØ¬Ø§Ù‡ MACD
    macd = compute_macd(df)
    if macd["trend"] == "bullish" and macd["above_zero"]:
        factors["macd_trend"] = 2
    elif macd["trend"] == "bearish" and not macd["above_zero"]:
        factors["macd_trend"] = 2
    elif macd["crossover"] != "none":
        factors["macd_trend"] = 1
        
    # 6. Ù…Ø­Ø§Ø°Ø§Ø© VWAP
    vwap_data = compute_vwap(df)
    deviation = abs(vwap_data["deviation"])
    if deviation > 2.0 and vwap_data["price_above_vwap"]:
        factors["vwap_alignment"] = 2
    elif deviation > 1.0:
        factors["vwap_alignment"] = 1
        
    # 7. ØªØ£ÙƒÙŠØ¯ SMC
    order_blocks = smc_data.get("order_blocks", {})
    fvg_zones = smc_data.get("fvg_zones", {})
    
    smc_confirmation = 0
    for ob in order_blocks.get("bullish_ob", []) + order_blocks.get("bearish_ob", []):
        if ob['low'] <= current_price <= ob['high']:
            smc_confirmation += 2
            
    for fvg in fvg_zones.get("bullish_fvg", []) + fvg_zones.get("bearish_fvg", []):
        if fvg['low'] <= current_price <= fvg['high']:
            smc_confirmation += 1
            
    factors["smc_confirmation"] = min(3, smc_confirmation)
    
    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
    total_score = sum(factors.values())
    max_possible = 18  # 7 Ø¹ÙˆØ§Ù…Ù„ Ã— 3 Ù†Ù‚Ø§Ø· ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
    
    confidence = total_score / max_possible
    mode = "trend" if total_score >= 10 else "scalp"
    
    # Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù‚Ø±Ø§Ø±
    reasons = []
    for factor, score in factors.items():
        if score > 0:
            reasons.append(f"{factor}:{score}")
    
    return {
        "mode": mode,
        "confidence": round(confidence, 2),
        "total_score": total_score,
        "factors": factors,
        "reasons": reasons
    }

# =================== PROFESSIONAL COUNCIL WITH SMC ===================
def ultimate_council_professional(df):
    """Ù…Ø¬Ù„Ø³ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªØ±Ù Ù…Ø¹ SMC ÙˆØ§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©"""
    try:
        # Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        current_price = last_val(df['close'])
        ind = compute_indicators(df)
        rsi_ctx = rsi_ma_context(df)
        candles = compute_candles(df)
        
        # Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        volume_momentum = enhanced_volume_momentum(df)
        stoch_rsi = stochastic_rsi_enhanced(df)
        pivots = dynamic_pivot_points(df)
        trend_indicator = dynamic_trend_indicator(df)
        footprint = advanced_footprint_analysis(df, current_price)
        
        # Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
        macd = compute_macd(df)
        vwap = compute_vwap(df)
        advanced_momentum = compute_advanced_momentum(df)
        
        # ØªØ­Ù„ÙŠÙ„ SMC Ø§Ù„Ù…ØªÙ‚Ø¯Ù… - Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
        try:
            liquidity_zones = detect_liquidity_zones(df)
        except Exception as e:
            log_w(f"SMC liquidity_zones error: {e}")
            liquidity_zones = {"buy_liquidity": [], "sell_liquidity": []}
            
        try:
            fvg_zones = detect_fvg(df)
        except Exception as e:
            log_w(f"SMC fvg_zones error: {e}")
            fvg_zones = {"bullish_fvg": [], "bearish_fvg": []}
            
        try:
            market_structure = detect_market_structure(df)
        except Exception as e:
            log_w(f"SMC market_structure error: {e}")
            market_structure = {"trend": "neutral", "bos_bullish": False, "bos_bearish": False, 
                               "choch_bullish": False, "choch_bearish": False, "liquidity_sweep": False}
            
        try:
            order_blocks = detect_order_blocks(df)
        except Exception as e:
            log_w(f"SMC order_blocks error: {e}")
            order_blocks = {"bullish_ob": [], "bearish_ob": []}
        
        # Ù†Ø¸Ø§Ù… Ø§Ù„ØªØµÙˆÙŠØª Ø§Ù„Ù…Ø­ØªØ±Ù
        votes_buy = 0
        votes_sell = 0
        confidence_buy = 0.0
        confidence_sell = 0.0
        detailed_logs = []
        
        # === 1. ØªØ­Ù„ÙŠÙ„ SMC ÙˆÙ‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ (Ø£Ø¹Ù„Ù‰ ÙˆØ²Ù†) ===
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠ
        if market_structure["trend"] == "bullish":
            votes_buy += 3
            confidence_buy += 2.5
            detailed_logs.append("ğŸ“Š Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ ØµØ§Ø¹Ø¯")
        
        if market_structure["trend"] == "bearish":
            votes_sell += 3
            confidence_sell += 2.5
            detailed_logs.append("ğŸ“Š Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù‡Ø§Ø¨Ø·")
        
        # Break of Structure
        if market_structure["bos_bullish"]:
            votes_buy += 4
            confidence_buy += 3.0
            detailed_logs.append("ğŸš€ BOS ØµØ§Ø¹Ø¯ - Ø§Ø®ØªØ±Ø§Ù‚ Ù‡ÙŠÙƒÙ„")
        
        if market_structure["bos_bearish"]:
            votes_sell += 4
            confidence_sell += 3.0
            detailed_logs.append("ğŸ’¥ BOS Ù‡Ø§Ø¨Ø· - Ø§Ø®ØªØ±Ø§Ù‚ Ù‡ÙŠÙƒÙ„")
        
        # Liquidity Sweep
        if market_structure.get("liquidity_sweep"):
            # Ù…Ø³Ø­ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø¹Ø§Ø¯Ø©Ù‹ ÙŠØ³Ø¨Ù‚ Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³
            sweep_direction = "buy" if market_structure.get("bos_bullish") else "sell"
            if sweep_direction == "buy":
                votes_buy += 2
                confidence_buy += 1.5
                detailed_logs.append("ğŸ’° Ù…Ø³Ø­ Ø³ÙŠÙˆÙ„Ø© Ø´Ø±Ø§Ø¡")
            else:
                votes_sell += 2
                confidence_sell += 1.5
                detailed_logs.append("ğŸ’° Ù…Ø³Ø­ Ø³ÙŠÙˆÙ„Ø© Ø¨ÙŠØ¹")
        
        # === 2. ØªØ­Ù„ÙŠÙ„ Order Blocks ===
        current_time = df['time'].iloc[-1] if hasattr(df['time'], 'iloc') else df['time'][-1]
        
        # ØªØ­Ù‚Ù‚ Ù…Ù† Order Blocks Ø§Ù„Ù‚Ø±ÙŠØ¨Ø©
        for ob in order_blocks["bullish_ob"]:
            if (ob['low'] <= current_price <= ob['high'] and 
                (current_time - ob['time']) / 1000 < 86400):  # within 24 hours
                votes_buy += 3
                confidence_buy += 2.0
                detailed_logs.append(f"ğŸŸ¢ Order Block Ø´Ø±Ø§Ø¡ Ù‚ÙˆÙŠ: {ob['strength']:.1f}%")
        
        for ob in order_blocks["bearish_ob"]:
            if (ob['low'] <= current_price <= ob['high'] and 
                (current_time - ob['time']) / 1000 < 86400):  # within 24 hours
                votes_sell += 3
                confidence_sell += 2.0
                detailed_logs.append(f"ğŸ”´ Order Block Ø¨ÙŠØ¹ Ù‚ÙˆÙŠ: {ob['strength']:.1f}%")
        
        # === 3. ØªØ­Ù„ÙŠÙ„ FVG ===
        for fvg in fvg_zones["bullish_fvg"]:
            if fvg['low'] <= current_price <= fvg['high']:
                votes_buy += 2
                confidence_buy += 1.5
                detailed_logs.append(f"ğŸ“ˆ FVG ØµØ§Ø¹Ø¯: {fvg['strength']:.2f}%")
        
        for fvg in fvg_zones["bearish_fvg"]:
            if fvg['low'] <= current_price <= fvg['high']:
                votes_sell += 2
                confidence_sell += 1.5
                detailed_logs.append(f"ğŸ“‰ FVG Ù‡Ø§Ø¨Ø·: {fvg['strength']:.2f}%")
        
        # === 4. ØªØ­Ù„ÙŠÙ„ Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© ===
        for level in liquidity_zones["buy_liquidity"]:
            if abs(current_price - level['price']) / current_price <= LIQUIDITY_ZONE_PROXIMITY:  # within proximity
                votes_buy += 2
                confidence_buy += 1.0
                detailed_logs.append(f"ğŸ¦ Ø¯Ø¹Ù… Ù‚ÙˆÙŠ: {level['price']:.6f}")
        
        for level in liquidity_zones["sell_liquidity"]:
            if abs(current_price - level['price']) / current_price <= LIQUIDITY_ZONE_PROXIMITY:  # within proximity
                votes_sell += 2
                confidence_sell += 1.0
                detailed_logs.append(f"ğŸ¦ Ù…Ù‚Ø§ÙˆÙ…Ø© Ù‚ÙˆÙŠØ©: {level['price']:.6f}")
        
        # === 5. Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ===
        
        # MACD
        if macd["crossover"] == "bullish" and macd["above_zero"]:
            votes_buy += 2
            confidence_buy += 1.5
            detailed_logs.append("ğŸ“ˆ MACD Ø¥ÙŠØ¬Ø§Ø¨ÙŠ Ù‚ÙˆÙŠ")
        elif macd["crossover"] == "bullish":
            votes_buy += 1
            confidence_buy += 1.0
            detailed_logs.append("ğŸ“ˆ MACD Ø¥ÙŠØ¬Ø§Ø¨ÙŠ")
        
        if macd["crossover"] == "bearish" and not macd["above_zero"]:
            votes_sell += 2
            confidence_sell += 1.5
            detailed_logs.append("ğŸ“‰ MACD Ø³Ù„Ø¨ÙŠ Ù‚ÙˆÙŠ")
        elif macd["crossover"] == "bearish":
            votes_sell += 1
            confidence_sell += 1.0
            detailed_logs.append("ğŸ“‰ MACD Ø³Ù„Ø¨ÙŠ")
        
        # VWAP
        if vwap["signal"] == "bullish" and vwap["price_above_vwap"]:
            votes_buy += 1
            confidence_buy += 0.8
            detailed_logs.append("âš¡ VWAP Ø¥ÙŠØ¬Ø§Ø¨ÙŠ")
        
        if vwap["signal"] == "bearish" and not vwap["price_above_vwap"]:
            votes_sell += 1
            confidence_sell += 0.8
            detailed_logs.append("âš¡ VWAP Ø³Ù„Ø¨ÙŠ")
        
        # Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        if advanced_momentum["trend"] == "strong_bullish":
            votes_buy += 2
            confidence_buy += 1.5
            detailed_logs.append(f"ğŸš€ Ø²Ø®Ù… ØµØ§Ø¹Ø¯ Ù‚ÙˆÙŠ: {advanced_momentum['momentum']:.2f}%")
        elif advanced_momentum["trend"] == "bullish":
            votes_buy += 1
            confidence_buy += 1.0
        
        if advanced_momentum["trend"] == "strong_bearish":
            votes_sell += 2
            confidence_sell += 1.5
            detailed_logs.append(f"ğŸ’¥ Ø²Ø®Ù… Ù‡Ø§Ø¨Ø· Ù‚ÙˆÙŠ: {advanced_momentum['momentum']:.2f}%")
        elif advanced_momentum["trend"] == "bearish":
            votes_sell += 1
            confidence_sell += 1.0
        
        # === 6. Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø§Ù„Ù…Ø¹Ø²Ø²Ø© ===
        
        # Footprint Analysis
        if footprint.get("ok"):
            fp_bull = footprint.get("footprint_score_bull", 0)
            fp_bear = footprint.get("footprint_score_bear", 0)
            
            if fp_bull > 2.0:
                votes_buy += 3
                confidence_buy += min(2.5, fp_bull)
                detailed_logs.append(f"ğŸ‘£ Footprint ØµØ§Ø¹Ø¯: {fp_bull:.1f}")
            
            if fp_bear > 2.0:
                votes_sell += 3
                confidence_sell += min(2.5, fp_bear)
                detailed_logs.append(f"ğŸ‘£ Footprint Ù‡Ø§Ø¨Ø·: {fp_bear:.1f}")
        
        # Trend Indicator
        if trend_indicator["signal"] in ["strong_buy", "buy"]:
            votes_buy += 2
            confidence_buy += 1.5
        
        if trend_indicator["signal"] in ["strong_sell", "sell"]:
            votes_sell += 2
            confidence_sell += 1.5
        
        # Volume Momentum
        if volume_momentum["trend"] == "bull" and volume_momentum["strength"] > 2.0:
            votes_buy += 2
            confidence_buy += 1.2
        
        if volume_momentum["trend"] == "bear" and volume_momentum["strength"] > 2.0:
            votes_sell += 2
            confidence_sell += 1.2
        
        # === 7. ØªØµÙÙŠØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªØ¶Ø§Ø±Ø¨Ø© ===
        
        if votes_buy > 0 and votes_sell > 0:
            # Ø£ÙˆÙ„ÙˆÙŠØ© SMC ÙˆÙ‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚
            smc_strength_buy = any("Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ ØµØ§Ø¹Ø¯" in log or "BOS ØµØ§Ø¹Ø¯" in log for log in detailed_logs)
            smc_strength_sell = any("Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù‡Ø§Ø¨Ø·" in log or "BOS Ù‡Ø§Ø¨Ø·" in log for log in detailed_logs)
            
            if smc_strength_buy and not smc_strength_sell:
                votes_sell = 0
                confidence_sell = 0
                detailed_logs.append("ğŸ”„ ØªØ±Ø¬ÙŠØ­ Ø§Ù„Ø´Ø±Ø§Ø¡ (SMC Ù‚ÙˆÙŠ)")
            elif smc_strength_sell and not smc_strength_buy:
                votes_buy = 0
                confidence_buy = 0
                detailed_logs.append("ğŸ”„ ØªØ±Ø¬ÙŠØ­ Ø§Ù„Ø¨ÙŠØ¹ (SMC Ù‚ÙˆÙŠ)")
            elif confidence_buy > confidence_sell:
                votes_sell = 0
                confidence_sell = 0
                detailed_logs.append("ğŸ”„ ØªØ±Ø¬ÙŠØ­ Ø§Ù„Ø´Ø±Ø§Ø¡ (Ø«Ù‚Ø© Ø£Ø¹Ù„Ù‰)")
            else:
                votes_buy = 0
                confidence_buy = 0
                detailed_logs.append("ğŸ”„ ØªØ±Ø¬ÙŠØ­ Ø§Ù„Ø¨ÙŠØ¹ (Ø«Ù‚Ø© Ø£Ø¹Ù„Ù‰)")
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        ind.update({
            "macd": macd,
            "vwap": vwap,
            "advanced_momentum": advanced_momentum,
            "liquidity_zones": liquidity_zones,
            "fvg_zones": fvg_zones,
            "market_structure": market_structure,
            "order_blocks": order_blocks,
            "professional_votes_buy": votes_buy,
            "professional_votes_sell": votes_sell,
            "professional_confidence_buy": confidence_buy,
            "professional_confidence_sell": confidence_sell
        })
        
        return {
            "b": votes_buy, "s": votes_sell,
            "score_b": confidence_buy, "score_s": confidence_sell,
            "logs": detailed_logs, 
            "ind": ind, 
            "candles": candles,
            "advanced_indicators": {
                "volume_momentum": volume_momentum,
                "stoch_rsi": stoch_rsi,
                "pivots": pivots,
                "trend_indicator": trend_indicator,
                "footprint": footprint,
                "macd": macd,
                "vwap": vwap,
                "advanced_momentum": advanced_momentum,
                "smc_analysis": {
                    "liquidity_zones": liquidity_zones,
                    "fvg_zones": fvg_zones,
                    "market_structure": market_structure,
                    "order_blocks": order_blocks
                }
            }
        }
        
    except Exception as e:
        log_w(f"ultimate_council_professional error: {e}")
        return {"b":0, "s":0, "score_b":0.0, "score_s":0.0, "logs":[], "ind":{}, "candles":{}}

# =================== ENHANCED POSITION MANAGEMENT ===================
def manage_enhanced_position_with_monitoring(df, ind, info, council_data, strategy_mode):
    """Ø¥Ø¯Ø§Ø±Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ù„ØµÙÙ‚Ø© Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø°ÙƒÙŠØ©"""
    if not STATE["open"] or STATE["qty"] <= 0:
        return

    current_price = info["price"]
    entry_price = STATE["entry"]
    side = STATE["side"]
    current_qty = STATE["qty"]
    
    # Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙØ¹Ù„Ø©
    if not position_monitor.monitoring_active:
        position_monitor.start_monitoring(entry_price, side, strategy_mode)
    
    # ğŸ”¥ ØªØ´ØºÙŠÙ„ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…ÙƒØ«ÙØ©
    monitoring_result = position_monitor.intensive_monitoring_cycle(
        df, current_price, side, entry_price, council_data
    )
    
    # ØªØ·Ø¨ÙŠÙ‚ ØªÙˆØµÙŠØ§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
    if monitoring_result["recommendation"].startswith("close"):
        handle_monitoring_exit_signal(monitoring_result, current_price, side, current_qty)
    elif monitoring_result["recommendation"].startswith("continue"):
        handle_continue_signal(monitoring_result, current_price, side, entry_price)
    
    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
    if monitoring_result["dynamic_targets"]:
        STATE["dynamic_targets"] = monitoring_result["dynamic_targets"]
    
    # Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    manage_after_entry_professional(df, ind, info)

def handle_monitoring_exit_signal(monitoring_result, current_price, side, current_qty):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©"""
    recommendation = monitoring_result["recommendation"]
    reasons = monitoring_result["detailed_reasons"]
    
    if recommendation == "close_immediate":
        # Ø¥ØºÙ„Ø§Ù‚ ÙÙˆØ±ÙŠ - Ø·ÙˆØ§Ø±Ø¦
        log_w(f"ğŸš¨ Ø¥ØºÙ„Ø§Ù‚ ÙÙˆØ±ÙŠ: {', '.join(reasons)}")
        close_market_strict("monitoring_emergency_exit")
        position_monitor.stop_monitoring()
        
    elif recommendation == "close_aggressive":
        # Ø¥ØºÙ„Ø§Ù‚ Ø¬Ø²Ø¦ÙŠ ÙƒØ¨ÙŠØ±
        close_fraction = 0.7  # 70%
        close_qty = safe_qty(current_qty * close_fraction)
        execute_partial_close(side, close_qty, f"monitoring_aggressive_exit: {', '.join(reasons)}")
        
    elif recommendation == "close_moderate":
        # Ø¥ØºÙ„Ø§Ù‚ Ø¬Ø²Ø¦ÙŠ Ù…Ø¹ØªØ¯Ù„
        close_fraction = 0.4  # 40%
        close_qty = safe_qty(current_qty * close_fraction)
        execute_partial_close(side, close_qty, f"monitoring_moderate_exit: {', '.join(reasons)}")

def handle_continue_signal(monitoring_result, current_price, side, entry_price):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± Ù…Ù† Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©"""
    recommendation = monitoring_result["recommendation"]
    reasons = monitoring_result["detailed_reasons"]
    
    if recommendation == "continue_strong":
        # Ø§Ø³ØªÙ…Ø±Ø§Ø± Ù‚ÙˆÙŠ - ÙŠÙ…ÙƒÙ† Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©
        log_i(f"ğŸš€ Ø§Ø³ØªÙ…Ø±Ø§Ø± Ù‚ÙˆÙŠ: {', '.join(reasons)}")
        # ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø¬Ù… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª
        
    elif recommendation == "continue_moderate":
        # Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¹Ø§Ø¯ÙŠ - Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ
        log_i(f"âœ… Ø§Ø³ØªÙ…Ø±Ø§Ø±: {', '.join(reasons)}")

def execute_partial_close(side, close_qty, reason):
    """ØªÙ†ÙÙŠØ° Ø¥ØºÙ„Ø§Ù‚ Ø¬Ø²Ø¦ÙŠ"""
    if close_qty <= 0:
        return
        
    close_side = "sell" if side == "long" else "buy"
    
    if MODE_LIVE and EXECUTE_ORDERS and not DRY_RUN:
        try:
            params = exchange_specific_params(close_side, is_close=True)
            ex.create_order(SYMBOL, "market", close_side, close_qty, None, params)
            log_g(f"âœ… Ø¥ØºÙ„Ø§Ù‚ Ø¬Ø²Ø¦ÙŠ: {close_qty:.4f} | {reason}")
            STATE["qty"] = safe_qty(STATE["qty"] - close_qty)
        except Exception as e:
            log_e(f"âŒ ÙØ´Ù„ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¬Ø²Ø¦ÙŠ: {e}")
    else:
        log_i(f"DRY_RUN: Ø¥ØºÙ„Ø§Ù‚ Ø¬Ø²Ø¦ÙŠ {close_qty:.4f} | {reason}")

# =================== PROFESSIONAL TRADE MANAGEMENT ===================
def manage_after_entry_professional(df, ind, info):
    """Ø¥Ø¯Ø§Ø±Ø© ØµÙÙ‚Ø§Øª Ù…Ø­ØªØ±ÙØ© Ù…Ø¹ Ø¬Ù†ÙŠ Ø£Ø±Ø¨Ø§Ø­ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ"""
    if not STATE["open"] or STATE["qty"] <= 0:
        return {"action": "hold", "reason": "Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙÙ‚Ø© Ù…ÙØªÙˆØ­Ø©"}
    
    entry = STATE["entry"]
    side = STATE["side"]
    qty = STATE["qty"]
    
    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©
    current_price = info["price"]
    unrealized_pnl_pct = (current_price - entry) / entry * 100 * (1 if side == "long" else -1)
    
    # ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø§Ù… Ø§Ù„ØµØ¨Ø± Ø§Ù„Ø°ÙƒÙŠ
    should_hold = smart_patience.should_hold_position(
        STATE.get("entry_time"), unrealized_pnl_pct, df, ind.get('atr', 0), current_price
    )
    
    if not should_hold and unrealized_pnl_pct > 0.1:  # Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„ØµØ¨Ø± ÙˆÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±Ø¨Ø­
        # Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        profit_signal = profit_manager.should_take_profit(
            unrealized_pnl_pct, 
            STATE.get("profit_targets_achieved", 0),
            STATE.get("dynamic_targets", [0.5, 1.0, 1.5]),
            df, side, entry, {}
        )
        
        if profit_signal[0]:
            log_w(f"ğŸš¨ Ø¬Ù†ÙŠ Ø£Ø±Ø¨Ø§Ø­ Ù…Ø­Ø³Ù‘Ù†: {profit_signal[1]}")
            close_market_strict(f"enhanced_profit_taking_{profit_signal[1]}")
            return
    
    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø­Ø§Ù„ÙŠ
    market_structure = detect_market_structure(df)
    advanced_momentum = compute_advanced_momentum(df)
    macd = compute_macd(df)
    
    # ØªØ­Ø¯ÙŠØ¯ Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¸Ø±ÙˆÙ Ø§Ù„Ø³ÙˆÙ‚
    if market_structure["trend"] == "strong_bullish" and side == "long":
        # ÙÙŠ Ø§ØªØ¬Ø§Ù‡ ØµØ§Ø¹Ø¯ Ù‚ÙˆÙŠ - Ø£Ù‡Ø¯Ø§Ù Ø£Ø¹Ù„Ù‰
        tp_levels = [1.0, 2.0, 3.5]
        tp_fractions = [0.25, 0.35, 0.40]
    elif market_structure["trend"] == "strong_bearish" and side == "short":
        # ÙÙŠ Ø§ØªØ¬Ø§Ù‡ Ù‡Ø§Ø¨Ø· Ù‚ÙˆÙŠ - Ø£Ù‡Ø¯Ø§Ù Ø£Ø¹Ù„Ù‰
        tp_levels = [1.0, 2.0, 3.5]
        tp_fractions = [0.25, 0.35, 0.40]
    elif advanced_momentum["strength"] > 2.0:
        # Ø²Ø®Ù… Ù‚ÙˆÙŠ - Ø£Ù‡Ø¯Ø§Ù Ù…ØªÙˆØ³Ø·Ø©
        tp_levels = [0.8, 1.5, 2.5]
        tp_fractions = [0.3, 0.3, 0.4]
    else:
        # Ø¸Ø±ÙˆÙ Ø¹Ø§Ø¯ÙŠØ© - Ø£Ù‡Ø¯Ø§Ù Ù…Ø­Ø§ÙØ¸Ø©
        tp_levels = [0.6, 1.2, 2.0]
        tp_fractions = [0.4, 0.3, 0.3]
    
    # Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª
    achieved_tps = STATE.get("profit_targets_achieved", 0)
    
    if achieved_tps < len(tp_levels) and unrealized_pnl_pct >= tp_levels[achieved_tps]:
        close_fraction = tp_fractions[achieved_tps]
        return {
            "action": "partial_close",
            "reason": f"Ø¬Ù†ÙŠ Ø£Ø±Ø¨Ø§Ø­ Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ {achieved_tps + 1} ({tp_levels[achieved_tps]}%)",
            "close_fraction": close_fraction,
            "tp_level": tp_levels[achieved_tps],
            "new_achieved_tps": achieved_tps + 1
        }
    
    # ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ù…ØªØ­Ø±Ùƒ Ø§Ù„Ø°ÙƒÙŠ
    if unrealized_pnl_pct > 0.5:  # Ø¨Ø¯Ø¡ Ø§Ù„ØªØ±ÙŠÙ„ Ø¨Ø¹Ø¯ ØªØ­Ù‚ÙŠÙ‚ Ø±Ø¨Ø­ 0.5%
        atr = compute_indicators(df).get('atr', 0.001)
        
        if side == "long":
            # ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ØµØ§Ø¹Ø¯ØŒ Ø§Ø³ØªØ®Ø¯Ù… ØªØ±ÙŠÙ„ Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø©
            trail_distance = atr * (1.2 if unrealized_pnl_pct < 1.5 else 0.8)
            new_trail = current_price - trail_distance
        else:
            # ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù‡Ø§Ø¨Ø·ØŒ Ø§Ø³ØªØ®Ø¯Ù… ØªØ±ÙŠÙ„ Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø©
            trail_distance = atr * (1.2 if unrealized_pnl_pct < 1.5 else 0.8)
            new_trail = current_price + trail_distance
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ±ÙŠÙ„ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£ÙØ¶Ù„
        if STATE.get("trail") is None:
            STATE["trail"] = new_trail
        elif (side == "long" and new_trail > STATE["trail"]) or \
             (side == "short" and new_trail < STATE["trail"]):
            STATE["trail"] = new_trail
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ±ÙŠÙ„
        if STATE.get("trail"):
            if (side == "long" and current_price <= STATE["trail"]) or \
               (side == "short" and current_price >= STATE["trail"]):
                return {
                    "action": "close", 
                    "reason": "ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø© Ù…ØªØ­Ø±Ùƒ Ù…Ø­Ø³Ù†",
                    "trail_price": STATE["trail"],
                    "pnl_pct": unrealized_pnl_pct
                }
    
    # Ø¥ØºÙ„Ø§Ù‚ Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ Ø¹Ù†Ø¯ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³
    if unrealized_pnl_pct > 1.0:  # ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±Ø¨Ø­
        reversal_signals = 0
        
        # MACD Ø§Ù†Ø¹ÙƒØ§Ø³
        if (side == "long" and macd["crossover"] == "bearish") or \
           (side == "short" and macd["crossover"] == "bullish"):
            reversal_signals += 1
        
        # ØªØºÙŠØ± Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚
        if (side == "long" and market_structure["choch_bearish"]) or \
           (side == "short" and market_structure["choch_bullish"]):
            reversal_signals += 1
        
        # ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø²Ø®Ù…
        if (side == "long" and advanced_momentum.get("trend") == "bearish") or \
           (side == "short" and advanced_momentum.get("trend") == "bullish"):
            reversal_signals += 1
        
        if reversal_signals >= 2:
            return {
                "action": "close", 
                "reason": "Ø§Ù†Ø¹ÙƒØ§Ø³ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª",
                "reversal_signals": reversal_signals,
                "pnl_pct": unrealized_pnl_pct
            }
    
    return {"action": "hold", "reason": "Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§Ù„ØµÙÙ‚Ø©"}

# =================== PROFESSIONAL EXECUTION ===================
def execute_professional_trade(side, price, qty, council_data):
    """ØªÙ†ÙÙŠØ° ØµÙÙ‚Ø§Øª Ù…Ø­ØªØ±Ù Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…"""
    if not EXECUTE_ORDERS or DRY_RUN:
        log_i(f"DRY_RUN: {side} {qty:.4f} @ {price:.6f}")
        return True
    
    if qty <= 0:
        log_e("âŒ ÙƒÙ…ÙŠØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù„ØªÙ†ÙÙŠØ°")
        return False

    # ØªØ­Ù„ÙŠÙ„ SMC Ù„Ù„Ù…Ø¯Ø®Ù„
    smc_data = council_data.get("advanced_indicators", {}).get("smc_analysis", {})
    market_structure = smc_data.get("market_structure", {})
    
    execution_note = ""
    if market_structure.get("bos_bullish") and side == "buy":
        execution_note = f" | ğŸš€ BOS ØµØ§Ø¹Ø¯"
    elif market_structure.get("bos_bearish") and side == "sell":
        execution_note = f" | ğŸ’¥ BOS Ù‡Ø§Ø¨Ø·"
    
    # ØªØ­Ù„ÙŠÙ„ Order Blocks
    order_blocks = smc_data.get("order_blocks", {})
    current_price = price
    ob_note = ""
    
    for ob in order_blocks.get("bullish_ob", []):
        if ob['low'] <= current_price <= ob['high']:
            ob_note = f" | ğŸŸ¢ OB Ù‚ÙˆÙŠ: {ob['strength']:.1f}%"
            break
    
    for ob in order_blocks.get("bearish_ob", []):
        if ob['low'] <= current_price <= ob['high']:
            ob_note = f" | ğŸ”´ OB Ù‚ÙˆÙŠ: {ob['strength']:.1f}%"
            break

    votes = council_data
    print(f"ğŸ¯ EXECUTE PROFESSIONAL: {side.upper()} {qty:.4f} @ {price:.6f} | "
          f"votes={votes['b']}/{votes['s']} score={votes['score_b']:.1f}/{votes['score_s']:.1f}"
          f"{execution_note}{ob_note}", flush=True)

    try:
        if MODE_LIVE:
            exchange_set_leverage(ex, LEVERAGE, SYMBOL)
            params = exchange_specific_params(side, is_close=False)
            ex.create_order(SYMBOL, "market", side, qty, None, params)
        
        log_g(f"âœ… EXECUTED PROFESSIONAL: {side.upper()} {qty:.4f} @ {price:.6f}")
        
        # ØªØ³Ø¬ÙŠÙ„ ØªÙØ§ØµÙŠÙ„ SMC ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
        if market_structure.get("bos_bullish") or market_structure.get("bos_bearish"):
            logging.info(f"SMC_ENTRY: {side} | BOS={market_structure.get('bos_bullish') or market_structure.get('bos_bearish')}")
        
        return True
    except Exception as e:
        log_e(f"âŒ EXECUTION FAILED: {e}")
        return False

# =================== ENHANCED TRADE EXECUTION ===================
def execute_enhanced_trade_with_monitoring(side, price, qty, council_data, strategy_mode):
    """ØªÙ†ÙÙŠØ° ØµÙÙ‚Ø© Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©"""
    success = execute_professional_trade(side, price, qty, council_data)
    
    if success:
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù„Ù„ØµÙÙ‚Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        position_monitor.start_monitoring(price, side, strategy_mode)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
        STATE.update({
            "entry_time": time.time(),
            "strategy_mode": strategy_mode["mode"],
            "strategy_confidence": strategy_mode["confidence"],
            "dynamic_targets": profit_manager.calculate_dynamic_targets(
                fetch_ohlcv(), price, side, strategy_mode["mode"], 
                compute_indicators(fetch_ohlcv()).get('atr', 0), 
                max(council_data['score_b'], council_data['score_s'])
            )["targets"]
        })
    
    return success

# =================== POSITION RECOVERY ===================
def _normalize_side(pos):
    side = pos.get("side") or pos.get("positionSide") or ""
    if side: return side.upper()
    qty = float(pos.get("contracts") or pos.get("positionAmt") or pos.get("size") or 0)
    return "LONG" if qty > 0 else ("SHORT" if qty < 0 else "")

def fetch_live_position(exchange, symbol: str):
    try:
        if hasattr(exchange, "fetch_positions"):
            arr = exchange.fetch_positions([symbol])
            for p in arr or []:
                sym = p.get("symbol") or p.get("info", {}).get("symbol")
                if sym and symbol.replace(":","") in sym.replace(":",""):
                    side = _normalize_side(p)
                    qty = abs(float(p.get("contracts") or p.get("positionAmt") or p.get("info",{}).get("size",0) or 0))
                    if qty > 0:
                        entry = float(p.get("entryPrice") or p.get("info",{}).get("entryPrice") or 0.0)
                        lev = float(p.get("leverage") or p.get("info",{}).get("leverage") or 0.0)
                        unr = float(p.get("unrealizedPnl") or 0.0)
                        return {"ok": True, "side": side, "qty": qty, "entry": entry, "unrealized": unr, "leverage": lev, "raw": p}
        if hasattr(exchange, "fetch_position"):
            p = exchange.fetch_position(symbol)
            side = _normalize_side(p); qty = abs(float(p.get("size") or 0))
            if qty > 0:
                entry = float(p.get("entryPrice") or 0.0)
                lev   = float(p.get("leverage") or 0.0)
                unr   = float(p.get("unrealizedPnl") or 0.0)
                return {"ok": True, "side": side, "qty": qty, "entry": entry, "unrealized": unr, "leverage": lev, "raw": p}
    except Exception as e:
        log_w(f"fetch_live_position error: {e}")
    return {"ok": False, "why": "no_open_position"}

def resume_open_position(exchange, symbol: str, state: dict) -> dict:
    if not RESUME_ON_RESTART:
        log_i("resume disabled"); return state

    live = fetch_live_position(exchange, symbol)
    if not live.get("ok"):
        log_i("no live position to resume"); return state

    ts = int(time.time())
    prev = load_state()
    if prev.get("ts") and (ts - int(prev["ts"])) > RESUME_LOOKBACK_SECS:
        log_w("found old local state â€” will override with exchange live snapshot")

    state.update({
        "in_position": True,
        "side": live["side"],
        "entry_price": live["entry"],
        "position_qty": live["qty"],
        "leverage": live.get("leverage") or state.get("leverage") or 10,
        "partial_taken": prev.get("partial_taken", False),
        "breakeven_armed": prev.get("breakeven_armed", False),
        "trail_active": prev.get("trail_active", False),
        "trail_tightened": prev.get("trail_tightened", False),
        "mode": prev.get("mode", "trend"),
        "gz_snapshot": prev.get("gz_snapshot", {}),
        "cv_snapshot": prev.get("cv_snapshot", {}),
        "opened_at": prev.get("opened_at", ts),
    })
    save_state(state)
    log_g(f"RESUME: {state['side']} qty={state['position_qty']} @ {state['entry_price']:.6f} lev={state['leverage']}x")
    return state

# =================== LOGGING SETUP ===================
def setup_file_logging():
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    if not any(isinstance(h, RotatingFileHandler) and getattr(h, "baseFilename", "").endswith("bot.log")
               for h in logger.handlers):
        fh = RotatingFileHandler("bot.log", maxBytes=5_000_000, backupCount=7, encoding="utf-8")
        fh.setFormatter(logging.Formatter("%(asctime)s %(levelname)s: %(message)s"))
        logger.addHandler(fh)
    logging.getLogger('werkzeug').setLevel(logging.ERROR)
    log_i("log rotation ready")

setup_file_logging()

# =================== HELPERS ===================
_consec_err = 0
last_loop_ts = time.time()

def _round_amt(q):
    if q is None: return 0.0
    try:
        d = Decimal(str(q))
        
        # ØªØ£ÙƒØ¯ Ø£Ù† LOT_STEP Ù‡Ùˆ float Ù‚Ø¨Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡
        step_val = LOT_STEP
        if step_val and isinstance(step_val, (int, float)) and step_val > 0:
            try:
                step_val = float(step_val)  # ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ float Ù„Ù„ØªØ£ÙƒØ¯
                step = Decimal(str(step_val))
                d = (d/step).to_integral_value(rounding=ROUND_DOWN) * step
            except (TypeError, ValueError, InvalidOperation) as e:
                log_w(f"Step rounding error: {e}, using direct rounding")
        
        prec = int(AMT_PREC) if AMT_PREC and AMT_PREC >= 0 else 0
        d = d.quantize(Decimal(1).scaleb(-prec), rounding=ROUND_DOWN)
        
        # ØªØ£ÙƒØ¯ Ø£Ù† LOT_MIN Ù‡Ùˆ float Ù‚Ø¨Ù„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
        min_val = LOT_MIN
        if min_val and isinstance(min_val, (int, float)) and min_val > 0:
            try:
                min_val = float(min_val)
                if d < Decimal(str(min_val)): 
                    return 0.0
            except (TypeError, ValueError) as e:
                log_w(f"Min qty check error: {e}")
                
        return float(d)
    except (InvalidOperation, ValueError, TypeError) as e:
        log_w(f"Rounding error for {q}: {e}")
        return max(0.0, float(q))

def safe_qty(q): 
    q = _round_amt(q)
    if q<=0: log_w(f"qty invalid after normalize â†’ {q}")
    return q

def fmt(v, d=6, na="â€”"):
    try:
        if v is None or (isinstance(v,float) and (math.isnan(v) or math.isinf(v))): return na
        return f"{float(v):.{d}f}"
    except Exception:
        return na

def with_retry(fn, tries=3, base_wait=0.4):
    global _consec_err
    for i in range(tries):
        try:
            r = fn()
            _consec_err = 0
            return r
        except Exception:
            _consec_err += 1
            if i == tries-1: raise
            time.sleep(base_wait*(2**i) + random.random()*0.25)

def fetch_ohlcv(limit=600):
    rows = with_retry(lambda: ex.fetch_ohlcv(SYMBOL, timeframe=INTERVAL, limit=limit, params={"type":"swap"}))
    return pd.DataFrame(rows, columns=["time","open","high","low","close","volume"])

def price_now():
    try:
        t = with_retry(lambda: ex.fetch_ticker(SYMBOL))
        return t.get("last") or t.get("close")
    except Exception: return None

def balance_usdt():
    if not MODE_LIVE: return 100.0
    try:
        b = with_retry(lambda: ex.fetch_balance(params={"type":"swap"}))
        return b.get("total",{}).get("USDT") or b.get("free",{}).get("USDT")
    except Exception: return None

def compute_size(balance, price):
    try:
        effective = float(balance or 0.0)
        capital = effective * float(RISK_ALLOC) * float(LEVERAGE)
        price_val = float(price or 0.0)
        
        if price_val <= 1e-9:
            log_e("âŒ Invalid price for size calculation")
            return 0.0
            
        raw = max(0.0, capital / price_val)
        log_i(f"Size calculation: balance={effective}, capital={capital}, price={price_val}, raw={raw}")
        
        return safe_qty(raw)
    except Exception as e:
        log_e(f"âŒ Compute size error: {e}")
        return 0.0

def orderbook_spread_bps():
    try:
        ob = with_retry(lambda: ex.fetch_order_book(SYMBOL, limit=5))
        bid = ob["bids"][0][0] if ob["bids"] else None
        ask = ob["asks"][0][0] if ob["asks"] else None
        if not (bid and ask): return None
        mid = (bid+ask)/2.0
        return ((ask-bid)/mid)*10000.0
    except Exception:
        return None

def _interval_seconds(iv: str) -> int:
    iv=(iv or "").lower().strip()
    if iv.endswith("m"): return int(float(iv[:-1]))*60
    if iv.endswith("h"): return int(float(iv[:-1]))*3600
    if iv.endswith("d"): return int(float(iv[:-1]))*86400
    return 15*60

def time_to_candle_close(df: pd.DataFrame) -> int:
    tf = _interval_seconds(INTERVAL)
    if len(df) == 0: return tf
    cur_start_ms = int(df["time"].iloc[-1])
    now_ms = int(time.time()*1000)
    next_close_ms = cur_start_ms + tf*1000
    while next_close_ms <= now_ms:
        next_close_ms += tf*1000
    left = max(0, next_close_ms - now_ms)
    return int(left/1000)

# ========= Professional logging helpers =========
def fmt_walls(walls):
    return ", ".join([f"{p:.6f}@{q:.0f}" for p, q in walls]) if walls else "-"

# ========= Bookmap snapshot =========
def bookmap_snapshot(exchange, symbol, depth=BOOKMAP_DEPTH):
    try:
        ob = exchange.fetch_order_book(symbol, depth)
        bids = ob.get("bids", [])[:depth]; asks = ob.get("asks", [])[:depth]
        if not bids or not asks:
            return {"ok": False, "why": "empty"}
        b_sizes = np.array([b[1] for b in bids]); b_prices = np.array([b[0] for b in bids])
        a_sizes = np.array([a[1] for a in asks]); a_prices = np.array([a[0] for a in asks])
        b_idx = b_sizes.argsort()[::-1][:BOOKMAP_TOPWALLS]
        a_idx = a_sizes.argsort()[::-1][:BOOKMAP_TOPWALLS]
        buy_walls = [(float(b_prices[i]), float(b_sizes[i])) for i in b_idx]
        sell_walls = [(float(a_prices[i]), float(a_sizes[i])) for i in a_idx]
        imb = b_sizes.sum() / max(a_sizes.sum(), 1e-12)
        return {"ok": True, "buy_walls": buy_walls, "sell_walls": sell_walls, "imbalance": float(imb)}
    except Exception as e:
        return {"ok": False, "why": f"{e}"}

# ========= Volume flow / Delta & CVD =========
def compute_flow_metrics(df):
    try:
        if len(df) < max(30, FLOW_WINDOW+2):
            return {"ok": False, "why": "short_df"}
        close = df["close"].astype(float).copy()
        vol = df["volume"].astype(float).copy()
        up_mask = close.diff().fillna(0) > 0
        up_vol = (vol * up_mask).astype(float)
        dn_vol = (vol * (~up_mask)).astype(float)
        delta = up_vol - dn_vol
        cvd = delta.cumsum()
        cvd_ma = cvd.rolling(CVD_SMOOTH).mean()
        wnd = delta.tail(FLOW_WINDOW)
        mu = float(wnd.mean()); sd = float(wnd.std() or 1e-12)
        z = float((last_val(wnd) - mu) / sd)
        trend = "up" if (last_val(cvd_ma) - safe_iloc(cvd_ma, -min(CVD_SMOOTH, len(cvd_ma)))) >= 0 else "down"
        return {"ok": True, "delta_last": last_val(delta), "delta_mean": mu, "delta_z": z,
                "cvd_last": last_val(cvd), "cvd_trend": trend, "spike": abs(z) >= FLOW_SPIKE_Z}
    except Exception as e:
        return {"ok": False, "why": str(e)}

# ========= Unified snapshot emitter =========
def emit_snapshots_with_smc(exchange, symbol, df, balance_fn=None, pnl_fn=None):
    """Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ Ø¹Ø±Ø¶ SMC"""
    try:
        bm = bookmap_snapshot(exchange, symbol)
        flow = compute_flow_metrics(df)
        cv = ultimate_council_professional(df)  # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¬Ù„Ø³ Ø§Ù„Ù…Ø­ØªØ±Ù
        mode = enhanced_strategy_mode_detection(df, cv)
        
        current_price = last_val(df['close'])
        footprint = advanced_footprint_analysis(df, current_price)

        bal = None; cpnl = None
        if callable(balance_fn):
            try: bal = balance_fn()
            except: bal = None
        if callable(pnl_fn):
            try: cpnl = pnl_fn()
            except: cpnl = None

        # Ø¹Ø±Ø¶ SMC ÙÙŠ Ø§Ù„Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯
        smc_note = ""
        smc_data = cv.get("advanced_indicators", {}).get("smc_analysis", {})
        market_structure = smc_data.get("market_structure", {})
        
        if market_structure.get("bos_bullish"):
            smc_note = f" | ğŸš€ BOS ØµØ§Ø¹Ø¯"
        elif market_structure.get("bos_bearish"):
            smc_note = f" | ğŸ’¥ BOS Ù‡Ø§Ø¨Ø·"
        
        # Ø¹Ø±Ø¶ Order Blocks
        ob_note = ""
        for ob in smc_data.get("order_blocks", {}).get("bullish_ob", []):
            if ob['low'] <= current_price <= ob['high']:
                ob_note = f" | ğŸŸ¢ OB:{ob['strength']:.1f}%"
                break
        
        for ob in smc_data.get("order_blocks", {}).get("bearish_ob", []):
            if ob['low'] <= current_price <= ob['high']:
                ob_note = f" | ğŸ”´ OB:{ob['strength']:.1f}%"
                break

        if bm.get("ok"):
            imb_tag = "ğŸŸ¢" if bm["imbalance"]>=IMBALANCE_ALERT else ("ğŸ”´" if bm["imbalance"]<=1/IMBALANCE_ALERT else "âš–ï¸")
            bm_note = f"Bookmap: {imb_tag} Imb={bm['imbalance']:.2f} | Buy[{fmt_walls(bm['buy_walls'])}] | Sell[{fmt_walls(bm['sell_walls'])}]"
        else:
            bm_note = f"Bookmap: N/A ({bm.get('why')})"

        if flow.get("ok"):
            dtag = "ğŸŸ¢Buy" if flow["delta_last"]>0 else ("ğŸ”´Sell" if flow["delta_last"]<0 else "âš–ï¸Flat")
            spk = " âš¡Spike" if flow["spike"] else ""
            fl_note = f"Flow: {dtag} Î”={flow['delta_last']:.0f} z={flow['delta_z']:.2f}{spk} | CVD {'â†—ï¸' if flow['cvd_trend']=='up' else 'â†˜ï¸'} {flow['cvd_last']:.0f}"
        else:
            fl_note = f"Flow: N/A ({flow.get('why')})"

        side_hint = "BUY" if cv["b"]>=cv["s"] else "SELL"
        dash = (f"DASH â†’ hint-{side_hint} | Council BUY({cv['b']},{cv['score_b']:.1f}) "
                f"SELL({cv['s']},{cv['score_s']:.1f}) | "
                f"RSI={cv['ind'].get('rsi',0):.1f} ADX={cv['ind'].get('adx',0):.1f} "
                f"DI={cv['ind'].get('di_spread',0):.1f}{smc_note}{ob_note}")

        strat_icon = "âš¡" if mode["mode"]=="scalp" else "ğŸ“ˆ" if mode["mode"]=="trend" else "â„¹ï¸"
        strat = f"Strategy: {strat_icon} {mode['mode'].upper()}"

        bal_note = f"Balance={bal:.2f}" if bal is not None else ""
        pnl_note = f"CompoundPnL={cpnl:.6f}" if cpnl is not None else ""
        wallet = (" | ".join(x for x in [bal_note, pnl_note] if x)) or ""

        if LOG_ADDONS:
            print(f"ğŸ§± {bm_note}", flush=True)
            print(f"ğŸ“¦ {fl_note}", flush=True)
            print(f"ğŸ“Š {dash}", flush=True)
            print(f"{strat}{(' | ' + wallet) if wallet else ''}", flush=True)
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù†Ø§Ùƒ Ø´ÙˆØª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
            flow_z = flow['delta_z'] if flow and flow.get('ok') else 0.0
            bm_imb = bm['imbalance'] if bm and bm.get('ok') else 1.0
            
            print(f"ğŸ§  SNAP PROFESSIONAL | {side_hint} | votes={cv['b']}/{cv['s']} score={cv['score_b']:.1f}/{cv['score_s']:.1f} "
                  f"| ADX={cv['ind'].get('adx',0):.1f} DI={cv['ind'].get('di_spread',0):.1f} | "
                  f"z={flow_z:.2f} | imb={bm_imb:.2f}{smc_note}{ob_note}", 
                  flush=True)
            
            print("âœ… PROFESSIONAL TRADING BOT LIVE", flush=True)

        return {"bm": bm, "flow": flow, "cv": cv, "mode": mode, "footprint": footprint, "wallet": wallet}
    except Exception as e:
        print(f"ğŸŸ¨ Professional AddonLog error: {e}", flush=True)
        return {"bm": None, "flow": None, "cv": {"b":0,"s":0,"score_b":0.0,"score_s":0.0,"ind":{}},
                "mode": {"mode":"n/a"}, "footprint": {}, "wallet": ""}

# =================== ENVIRONMENT VERIFICATION ===================
def verify_environment():
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© ÙˆØ§Ù„Ù…ØªØºÙŠØ±Ø§Øª"""
    log_i("ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ¦Ø© Ø§Ù„ØªÙ†ÙÙŠØ°...")
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø¯Ø¯ÙŠØ©
    numeric_vars = {
        "LOT_STEP": LOT_STEP,
        "LOT_MIN": LOT_MIN, 
        "AMT_PREC": AMT_PREC,
        "RISK_ALLOC": RISK_ALLOC,
        "LEVERAGE": LEVERAGE
    }
    
    for name, value in numeric_vars.items():
        try:
            float_val = float(value)
            log_g(f"âœ… {name}: {float_val} (ØµØ§Ù„Ø­)")
        except (TypeError, ValueError) as e:
            log_e(f"âŒ {name}: {value} (ØºÙŠØ± ØµØ§Ù„Ø­: {e})")
    
    # Ø§Ø®ØªØ¨Ø§Ø± Ø¯Ø§Ù„Ø© Ø§Ù„Ø­Ø³Ø§Ø¨
    test_cases = [
        (100.0, 4108.4),  # Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù„ÙˆØ¬
        (50.0, 2000.0),
        (200.0, 5000.0)
    ]
    
    for balance, price in test_cases:
        try:
            size = compute_size(balance, price)
            rounded = safe_qty(size)
            log_i(f"ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø­Ø³Ø§Ø¨: balance={balance}, price={price} -> raw={size:.6f}, safe={rounded:.6f}")
        except Exception as e:
            log_e(f"âŒ ÙØ´Ù„ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø­Ø³Ø§Ø¨: {e}")

# =================== ENHANCED TRADE LOOP ===================
def enhanced_trade_loop_with_intensive_monitoring():
    """Ø­Ù„Ù‚Ø© ØªØ¯Ø§ÙˆÙ„ Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…ÙƒØ«ÙØ©"""
    global wait_for_next_signal_side
    
    while True:
        try:
            # Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            bal = balance_usdt()
            px = price_now()
            df = fetch_ohlcv()
            info = rf_signal_live(df)
            ind = compute_indicators(df)
            
            # Ù…Ø¬Ù„Ø³ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­Ø³Ù‘Ù† Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
            is_monitoring = STATE["open"] and position_monitor.monitoring_active
            council_data = ultimate_council_professional(df)
            
            # ØªØ­Ø¯ÙŠØ¯ Ù†Ù…Ø· Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
            strategy_mode = enhanced_strategy_mode_detection(df, council_data)
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ Snapshots
            snap = emit_snapshots_with_smc(ex, SYMBOL, df,
                                balance_fn=lambda: float(bal) if bal else None,
                                pnl_fn=lambda: float(compound_pnl))
            
            # ğŸ”¥ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø°ÙƒÙŠØ©
            if STATE["open"]:
                manage_enhanced_position_with_monitoring(df, ind, info, council_data, strategy_mode)
            else:
                # Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ ØµÙÙ‚Ø©
                if position_monitor.monitoring_active:
                    position_monitor.stop_monitoring()
                
                # Ø§Ù„Ù†Ø¸Ø± ÙÙŠ Ø¯Ø®ÙˆÙ„ Ø¬Ø¯ÙŠØ¯
                consider_enhanced_entry(df, info, council_data, strategy_mode, bal, px)
            
            # Ù†ÙˆÙ… Ø°ÙƒÙŠ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
            sleep_time = calculate_adaptive_sleep_time(df, STATE["open"], position_monitor.monitoring_active)
            time.sleep(sleep_time)
            
        except Exception as e:
            log_e(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©: {e}\n{traceback.format_exc()}")
            time.sleep(BASE_SLEEP)

def consider_enhanced_entry(df, info, council_data, strategy_mode, balance, current_price):
    """Ø§Ù„Ù†Ø¸Ø± ÙÙŠ Ø¯Ø®ÙˆÙ„ Ù…Ø­Ø³Ù‘Ù†"""
    spread_bps = orderbook_spread_bps()
    
    if spread_bps and spread_bps > MAX_SPREAD_BPS:
        return
        
    # Ù‚Ø±Ø§Ø± Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
    min_confidence = 6.0 if strategy_mode["mode"] == "trend" else 7.0
    decision = None
    
    if (council_data["score_b"] >= min_confidence and 
        council_data["score_b"] > council_data["score_s"] + 1.5):
        decision = "BUY"
    elif (council_data["score_s"] >= min_confidence and 
          council_data["score_s"] > council_data["score_b"] + 1.5):
        decision = "SELL"
    
    if decision:
        qty = compute_size(balance, current_price or info["price"])
        if qty > 0:
            side = "buy" if decision == "BUY" else "sell"
            
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø­Ø³Ù‘Ù†
            ok = execute_enhanced_trade_with_monitoring(side, current_price or info["price"], qty, 
                                      council_data, strategy_mode)
            if ok:
                wait_for_next_signal_side = None

def calculate_adaptive_sleep_time(df, has_position, is_monitoring):
    """Ø­Ø³Ø§Ø¨ ÙˆÙ‚Øª Ù†ÙˆÙ… ØªÙƒÙŠÙÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„ØµÙÙ‚Ø© ÙˆØ§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©"""
    base_time = NEAR_CLOSE_S if time_to_candle_close(df) <= 15 else BASE_SLEEP
    
    if is_monitoring:
        # Ù…Ø±Ø§Ù‚Ø¨Ø© Ù†Ø´Ø·Ø© - ØªÙ‚Ù„ÙŠÙ„ ÙˆÙ‚Øª Ø§Ù„Ù†ÙˆÙ…
        return max(2, base_time * 0.5)
    elif has_position:
        # ØµÙÙ‚Ø© Ø¨Ø¯ÙˆÙ† Ù…Ø±Ø§Ù‚Ø¨Ø© Ù†Ø´Ø·Ø©
        return max(3, base_time * 0.7)
    else:
        # Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙÙ‚Ø©
        return min(10, base_time * 1.2)

# =================== EXECUTION MANAGER ===================
def close_market_strict(reason="STRICT"):
    global compound_pnl, wait_for_next_signal_side
    
    # Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø£ÙˆÙ„Ø§Ù‹
    if position_monitor.monitoring_active:
        position_monitor.stop_monitoring()
    
    exch_qty, exch_side, exch_entry = _read_position()
    if exch_qty <= 0:
        if STATE.get("open"):
            _reset_after_close(reason)
        return
    side_to_close = "sell" if (exch_side=="long") else "buy"
    qty_to_close  = safe_qty(exch_qty)
    attempts=0; last_error=None
    while attempts < CLOSE_RETRY_ATTEMPTS:
        try:
            if MODE_LIVE and EXECUTE_ORDERS and not DRY_RUN:
                params = exchange_specific_params(side_to_close, is_close=True)
                ex.create_order(SYMBOL,"market",side_to_close,qty_to_close,None,params)
            time.sleep(CLOSE_VERIFY_WAIT_S)
            left_qty, _, _ = _read_position()
            if left_qty <= 0:
                px = price_now() or STATE.get("entry")
                entry_px = STATE.get("entry") or exch_entry or px
                side = STATE.get("side") or exch_side or ("long" if side_to_close=="sell" else "short")
                qty  = exch_qty
                pnl  = (px - entry_px) * qty * (1 if side=="long" else -1)
                compound_pnl += pnl
                log_i(f"STRICT CLOSE {side} reason={reason} pnl={fmt(pnl)} total={fmt(compound_pnl)}")
                logging.info(f"STRICT_CLOSE {side} pnl={pnl} total={compound_pnl}")
                _reset_after_close(reason, prev_side=side)
                return
            qty_to_close = safe_qty(left_qty)
            attempts += 1
            log_w(f"strict close retry {attempts}/{CLOSE_RETRY_ATTEMPTS} â€” residual={fmt(left_qty,4)}")
            time.sleep(CLOSE_VERIFY_WAIT_S)
        except Exception as e:
            last_error = e; logging.error(f"close_market_strict attempt {attempts+1}: {e}"); attempts += 1; time.sleep(CLOSE_VERIFY_WAIT_S)
    log_e(f"STRICT CLOSE FAILED after {CLOSE_RETRY_ATTEMPTS} attempts â€” last error: {last_error}")
    logging.critical(f"STRICT CLOSE FAILED â€” last_error={last_error}")

def _reset_after_close(reason, prev_side=None):
    """Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚"""
    global wait_for_next_signal_side
    prev_side = prev_side or STATE.get("side")
    STATE.update({
        "open": False, "side": None, "entry": None, "qty": 0.0,
        "pnl": 0.0, "bars": 0, "trail": None, "breakeven": None,
        "tp1_done": False, "highest_profit_pct": 0.0, "profit_targets_achieved": 0,
        "trail_tightened": False, "partial_taken": False
    })
    save_state({"in_position": False, "position_qty": 0})
    
    # ØªÙØ¹ÙŠÙ„ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
    wait_for_next_signal_side = "sell" if prev_side=="long" else ("buy" if prev_side=="short" else None)
    logging.info(f"AFTER_CLOSE waiting_for={wait_for_next_signal_side}")

# =================== ORDERS ===================
def _read_position():
    try:
        poss = ex.fetch_positions(params={"type":"swap"})
        for p in poss:
            sym = (p.get("symbol") or p.get("info",{}).get("symbol") or "")
            if SYMBOL.split(":")[0] not in sym: continue
            qty = abs(float(p.get("contracts") or p.get("info",{}).get("positionAmt") or 0))
            if qty <= 0: return 0.0, None, None
            entry = float(p.get("entryPrice") or p.get("info",{}).get("avgEntryPrice") or 0)
            side_raw = (p.get("side") or p.get("info",{}).get("positionSide") or "").lower()
            side = "long" if ("long" in side_raw or float(p.get("cost",0))>0) else "short"
            return qty, side, entry
    except Exception as e:
        logging.error(f"_read_position error: {e}")
    return 0.0, None, None

# =================== INDICATORS ===================
def wilder_ema(s: pd.Series, n: int): 
    return s.ewm(alpha=1/n, adjust=False).mean()

def compute_indicators(df: pd.DataFrame):
    if len(df) < max(ATR_LEN, RSI_LEN, ADX_LEN) + 2:
        return {"rsi":50.0,"plus_di":0.0,"minus_di":0.0,"dx":0.0,"adx":0.0,"atr":0.0}
    c,h,l = df["close"].astype(float), df["high"].astype(float), df["low"].astype(float)
    tr = pd.concat([(h-l).abs(), (h-c.shift(1)).abs(), (l-c.shift(1)).abs()], axis=1).max(axis=1)
    atr = wilder_ema(tr, ATR_LEN)

    delta=c.diff(); up=delta.clip(lower=0.0); dn=(-delta).clip(lower=0.0)
    rs = wilder_ema(up, RSI_LEN) / wilder_ema(dn, RSI_LEN).replace(0,1e-12)
    rsi = 100 - (100/(1+rs))

    up_move=h.diff(); down_move=l.shift(1)-l
    plus_dm=up_move.where((up_move>down_move)&(up_move>0),0.0)
    minus_dm=down_move.where((down_move>up_move)&(down_move>0),0.0)
    plus_di=100*(wilder_ema(plus_dm, ADX_LEN)/atr.replace(0,1e-12))
    minus_di=100*(wilder_ema(minus_dm, ADX_LEN)/atr.replace(0,1e-12))
    dx=(100*(plus_di-minus_di).abs()/(plus_di+minus_di).replace(0,1e-12)).fillna(0.0)
    adx=wilder_ema(dx, ADX_LEN)

    return {
        "rsi": last_val(rsi), 
        "plus_di": last_val(plus_di),
        "minus_di": last_val(minus_di), 
        "dx": last_val(dx),
        "adx": last_val(adx), 
        "atr": last_val(atr),
        "di_spread": abs(last_val(plus_di) - last_val(minus_di))
    }

# =================== RANGE FILTER ===================
def _rng_size(src: pd.Series, qty: float, n: int) -> pd.Series:
    avrng = _ema((src - src.shift(1)).abs(), n); wper = (n*2)-1
    return _ema(avrng, wper) * qty

def _rng_filter(src: pd.Series, rsize: pd.Series):
    rf=[float(src.iloc[0])]
    for i in range(1,len(src)):
        prev=rf[-1]; x=float(src.iloc[i]); r=float(rsize.iloc[i]); cur=prev
        if x - r > prev: cur = x - r
        if x + r < prev: cur = x + r
        rf.append(cur)
    filt=pd.Series(rf, index=src.index, dtype="float64")
    return filt + rsize, filt - rsize, filt

def _ema(s, n): return s.ewm(span=n, adjust=False).mean()

def rf_signal_live(df: pd.DataFrame):
    if len(df) < RF_PERIOD + 3:
        i = -1
        price = float(df["close"].iloc[i]) if len(df) else None
        return {"time": int(df["time"].iloc[i]) if len(df) else int(time.time()*1000),
                "price": price or 0.0, "long": False, "short": False,
                "filter": price or 0.0, "hi": price or 0.0, "lo": price or 0.0}
    src = df[RF_SOURCE].astype(float)
    hi, lo, filt = _rng_filter(src, _rng_size(src, RF_MULT, RF_PERIOD))
    def _bps(a,b):
        try: return abs((a-b)/b)*10000.0
        except Exception: return 0.0
    p_now = last_val(src); p_prev = safe_iloc(src, -2)
    f_now = last_val(filt); f_prev = safe_iloc(filt, -2)
    long_flip  = (p_prev <= f_prev and p_now > f_now and _bps(p_now, f_now) >= RF_HYST_BPS)
    short_flip = (p_prev >= f_prev and p_now < f_now and _bps(p_now, f_now) >= RF_HYST_BPS)
    return {
        "time": int(df["time"].iloc[-1]), "price": p_now,
        "long": bool(long_flip), "short": bool(short_flip),
        "filter": f_now, "hi": last_val(hi), "lo": last_val(lo)
    }

# =================== STATE ===================
STATE = {
    "open": False, "side": None, "entry": None, "qty": 0.0,
    "pnl": 0.0, "bars": 0, "trail": None, "breakeven": None,
    "tp1_done": False, "highest_profit_pct": 0.0,
    "profit_targets_achieved": 0,
}
compound_pnl = 0.0
wait_for_next_signal_side = None

# =================== WAIT FOR NEXT SIGNAL ===================
def wait_gate_allow(df, info):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±"""
    if wait_for_next_signal_side is None: 
        return True, ""
    
    bar_ts = int(info.get("time") or 0)
    need = (wait_for_next_signal_side=="buy" and info.get("long")) or (wait_for_next_signal_side=="sell" and info.get("short"))
    
    if need:
        return True, ""
    return False, f"wait-for-next-RF({wait_for_next_signal_side})"

# =================== PROFESSIONAL DECISION LOGGING ===================
def log_professional_decision(council_data, decision):
    """ØªØ³Ø¬ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù… Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø¬Ù„Ø³ Ø§Ù„Ù…Ø­ØªØ±Ù"""
    votes = council_data
    advanced = votes.get("advanced_indicators", {})
    smc_data = advanced.get("smc_analysis", {})
    
    print(f"\nğŸ¯ Ù‚Ø±Ø§Ø± Ø§Ù„Ù…Ø¬Ù„Ø³ Ø§Ù„Ù…Ø­ØªØ±Ù:", flush=True)
    print(f"ğŸ“Š Ø§Ù„Ø£ØµÙˆØ§Øª: Ø´Ø±Ø§Ø¡ {votes['b']} | Ø¨ÙŠØ¹ {votes['s']}", flush=True)
    print(f"â­ Ø§Ù„Ø«Ù‚Ø©: Ø´Ø±Ø§Ø¡ {votes['score_b']:.1f} | Ø¨ÙŠØ¹ {votes['score_s']:.1f}", flush=True)
    print(f"ğŸ“ˆ Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ: {decision}", flush=True)
    
    # ØªÙØ§ØµÙŠÙ„ SMC
    market_structure = smc_data.get("market_structure", {})
    if market_structure.get("bos_bullish"):
        print(f"ğŸš€ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚: BOS ØµØ§Ø¹Ø¯", flush=True)
    elif market_structure.get("bos_bearish"):
        print(f"ğŸ’¥ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙˆÙ‚: BOS Ù‡Ø§Ø¨Ø·", flush=True)
    
    # ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
    if advanced.get("macd"):
        macd = advanced["macd"]
        print(f"ğŸ“ˆ MACD: {macd['crossover']} | ÙÙˆÙ‚ Ø§Ù„ØµÙØ±: {macd['above_zero']}", flush=True)
    
    if advanced.get("vwap"):
        vwap = advanced["vwap"]
        print(f"âš¡ VWAP: {vwap['signal']} | Ø§Ù†Ø­Ø±Ø§Ù: {vwap['deviation']:.2f}%", flush=True)
    
    if advanced.get("advanced_momentum"):
        momentum = advanced["advanced_momentum"]
        print(f"ğŸš€ Ø§Ù„Ø²Ø®Ù…: {momentum['trend']} | Ù‚ÙˆØ©: {momentum['strength']:.1f}", flush=True)
    
    print("â”€" * 80, flush=True)

# =================== ENHANCED TRADE JOURNAL ===================
class AdvancedTradeJournal:
    def __init__(self):
        self.entries = []
        self.failures = []
        
    def log_entry(self, side, price, qty, council_data, strategy_mode, analysis_log):
        """ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„ØµÙÙ‚Ø©"""
        entry = {
            "timestamp": datetime.now().isoformat(),
            "side": side,
            "price": price,
            "quantity": qty,
            "strategy_mode": strategy_mode,
            "council_confidence": max(council_data['score_b'], council_data['score_s']),
            "analysis_log": analysis_log,
            "advanced_indicators": council_data.get("advanced_indicators", {}),
            "status": "open"
        }
        self.entries.append(entry)
        
        # Ø·Ø¨Ø§Ø¹Ø© Ù…Ù„Ø®Øµ Ø§Ù„Ø¯Ø®ÙˆÙ„
        print(f"\nğŸ¯ ENTRY JOURNAL:", flush=True)
        print(f"â° Ø§Ù„ÙˆÙ‚Øª: {entry['timestamp']}", flush=True)
        print(f"ğŸ“ˆ Ø§Ù„Ø¬Ø§Ù†Ø¨: {side.upper()} | Ø§Ù„Ø³Ø¹Ø±: {price:.6f}", flush=True)
        print(f"ğŸ“Š Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©: {strategy_mode}", flush=True)
        print(f"â­ Ø§Ù„Ø«Ù‚Ø©: {entry['council_confidence']:.1f}", flush=True)
        print(f"ğŸ“‹ Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨: {', '.join(analysis_log.get('reasons', []))}", flush=True)
        if analysis_log.get('warnings'):
            print(f"âš ï¸ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª: {', '.join(analysis_log['warnings'])}", flush=True)
        print("â”€" * 80, flush=True)
    
    def log_exit(self, exit_price, pnl, exit_reason, additional_info=None):
        """ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬ Ø§Ù„ØµÙÙ‚Ø©"""
        if not self.entries:
            return
            
        last_entry = self.entries[-1]
        last_entry.update({
            "exit_timestamp": datetime.now().isoformat(),
            "exit_price": exit_price,
            "pnl": pnl,
            "exit_reason": exit_reason,
            "additional_info": additional_info,
            "status": "closed"
        })
        
        # Ø·Ø¨Ø§Ø¹Ø© Ù…Ù„Ø®Øµ Ø§Ù„Ø®Ø±ÙˆØ¬
        print(f"\nğŸ“¤ EXIT JOURNAL:", flush=True)
        print(f"â° Ø§Ù„ÙˆÙ‚Øª: {last_entry['exit_timestamp']}", flush=True)
        print(f"ğŸ’° PNL: {pnl:.6f} ({((pnl / last_entry['price']) * 100):.2f}%)", flush=True)
        print(f"ğŸ“‹ Ø³Ø¨Ø¨ Ø§Ù„Ø®Ø±ÙˆØ¬: {exit_reason}", flush=True)
        if additional_info:
            print(f"ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©: {additional_info}", flush=True)
        print("â”€" * 80, flush=True)
    
    def log_failure(self, side, price, qty, error, council_data):
        """ØªØ³Ø¬ÙŠÙ„ ÙØ´Ù„ Ø§Ù„ØµÙÙ‚Ø©"""
        failure = {
            "timestamp": datetime.now().isoformat(),
            "side": side,
            "price": price,
            "quantity": qty,
            "error": error,
            "council_data": council_data
        }
        self.failures.append(failure)
        
        print(f"\nâŒ FAILURE JOURNAL:", flush=True)
        print(f"â° Ø§Ù„ÙˆÙ‚Øª: {failure['timestamp']}", flush=True)
        print(f"ğŸš¨ Ø§Ù„Ø®Ø·Ø£: {error}", flush=True)
        print(f"ğŸ“Š Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù„Ø³: B={council_data['b']}/S={council_data['s']}", flush=True)
        print("â”€" * 80, flush=True)

trade_journal = AdvancedTradeJournal()

# =================== API / KEEPALIVE ===================
app = Flask(__name__)
@app.route("/")
def home():
    mode='LIVE' if MODE_LIVE else 'PAPER'
    return f"âœ… XAU Council PROFESSIONAL Bot â€” BINGX â€” {SYMBOL} {INTERVAL} â€” {mode} â€” Gold Trading â€” ENHANCED MONITORING"

@app.route("/metrics")
def metrics():
    return jsonify({
        "exchange": EXCHANGE_NAME,
        "symbol": SYMBOL, "interval": INTERVAL, "mode": "live" if MODE_LIVE else "paper",
        "leverage": LEVERAGE, "risk_alloc": RISK_ALLOC, "price": price_now(),
        "state": STATE, "compound_pnl": compound_pnl,
        "entry_mode": "PROFESSIONAL_COUNCIL_WITH_SMC", "wait_for_next_signal": wait_for_next_signal_side,
        "guards": {"max_spread_bps": MAX_SPREAD_BPS, "final_chunk_qty": FINAL_CHUNK_QTY},
        "enhanced_systems": {
            "smart_patience": smart_patience.monitoring_active,
            "intelligent_monitoring": position_monitor.monitoring_active,
            "advanced_profit": profit_manager.profit_targets != []
        }
    })

@app.route("/health")
def health():
    return jsonify({
        "ok": True, "exchange": EXCHANGE_NAME, "mode": "live" if MODE_LIVE else "paper",
        "open": STATE["open"], "side": STATE["side"], "qty": STATE["qty"],
        "compound_pnl": compound_pnl, "timestamp": datetime.utcnow().isoformat(),
        "entry_mode": "PROFESSIONAL_COUNCIL_WITH_SMC", "wait_for_next_signal": wait_for_next_signal_side,
        "enhanced_monitoring": position_monitor.monitoring_active
    }), 200

def keepalive_loop():
    url=(SELF_URL or "").strip().rstrip("/")
    if not url:
        log_w("keepalive disabled (SELF_URL not set)")
        return
    import requests
    sess=requests.Session(); sess.headers.update({"User-Agent":"rf-live-bot/keepalive"})
    log_i(f"KEEPALIVE every 50s â†’ {url}")
    while True:
        try: sess.get(url, timeout=8)
        except Exception: pass
        time.sleep(50)

# =================== INTEGRATION ===================
# Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¨Ø§Ù„Ø¥ØµØ¯Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©
trade_loop = enhanced_trade_loop_with_intensive_monitoring
ultimate_council_voting_with_footprint = ultimate_council_professional
manage_after_entry_ultimate = manage_after_entry_professional
execute_trade_decision_with_footprint = execute_professional_trade
emit_snapshots = emit_snapshots_with_smc

# =================== BOOT ===================
if __name__ == "__main__":
    log_banner("XAU COUNCIL PROFESSIONAL BOT - SMART MONEY CONCEPTS - ENHANCED MONITORING")
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø² Ø£ÙˆÙ„Ø§Ù‹
    symbol_valid = verify_symbol()
    if not symbol_valid:
        log_e("âŒ Invalid symbol configuration. Please check SYMBOL setting.")
        sys.exit(1)
    
    state = load_state() or {}
    state.setdefault("in_position", False)

    if RESUME_ON_RESTART:
        try:
            state = resume_open_position(ex, SYMBOL, state)
        except Exception as e:
            log_w(f"resume error: {e}\n{traceback.format_exc()}")

    verify_execution_environment()
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ¦Ø© ÙˆØ§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø¯Ø¯ÙŠØ©
    verify_environment()

    print(colored(f"ğŸ¯ EXCHANGE: {EXCHANGE_NAME.upper()} â€¢ SYMBOL: {SYMBOL} â€¢ TIMEFRAME: {INTERVAL}", "yellow"))
    print(colored(f"âš¡ RISK: {int(RISK_ALLOC*100)}% Ã— {LEVERAGE}x â€¢ PROFESSIONAL_COUNCIL=ENABLED", "yellow"))
    print(colored(f"ğŸ† PROFESSIONAL MIN CONFIDENCE: {ULTIMATE_MIN_CONFIDENCE}", "yellow"))
    print(colored(f"ğŸ“Š SMART MONEY CONCEPTS: BOS + Order Blocks + FVG + Liquidity Analysis", "yellow"))
    print(colored(f"ğŸ“ˆ ADVANCED INDICATORS: MACD + VWAP + Volume Momentum + Dynamic Pivots", "yellow"))
    print(colored(f"ğŸ‘£ FOOTPRINT ANALYSIS: Volume Analysis + Absorption + Real Momentum", "yellow"))
    print(colored(f"ğŸ’° CAPITAL MANAGEMENT: {int(RISK_ALLOC*100)}% allocation per trade | ISOLATED margin", "yellow"))
    print(colored(f"ğŸš€ ENHANCED SYSTEMS: Smart Patience + Intelligent Monitoring + Advanced Profit Management", "yellow"))
    print(colored(f"ğŸ” REAL-TIME MONITORING: Intensive position analysis every 30 seconds", "yellow"))
    print(colored(f"ğŸ¯ DYNAMIC TARGETS: Adaptive profit taking based on market conditions", "yellow"))
    print(colored(f"ğŸš€ EXECUTION: {'ACTIVE' if EXECUTE_ORDERS and not DRY_RUN else 'SIMULATION'}", "yellow"))
    
    logging.info("service startingâ€¦")
    signal.signal(signal.SIGTERM, lambda *_: sys.exit(0))
    signal.signal(signal.SIGINT,  lambda *_: sys.exit(0))
    
    import threading
    threading.Thread(target=trade_loop, daemon=True).start()
    threading.Thread(target=keepalive_loop, daemon=True).start()
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)
